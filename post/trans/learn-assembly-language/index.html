<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Learn Assembly Language 汇编语言学习(拙译) - Looper 的博客</title>
  <meta name="description" content="Index-0 原址：https://asmtutor.com/ 环境：nasm on x64 linux TL;DR 动机：程序员——多掌握几门计算机语言，还是有好处的 主题：汇编语言——">
  <meta name="author" content="Dylan Cheng"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Looper 的博客",
    
    "url": "https:\/\/newlooper.win"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/newlooper.win"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/newlooper.win",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/newlooper.win\/post\/trans\/learn-assembly-language\/",
          "name": "Learn assembly language 汇编语言学习(拙译)"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "Dylan Cheng"
  },
  "headline": "Learn Assembly Language 汇编语言学习(拙译)",
  "description" : "Index-0 原址：https:\/\/asmtutor.com\/ 环境：nasm on x64 linux TL;DR 动机：程序员——多掌握几门计算机语言，还是有好处的 主题：汇编语言——",
  "inLanguage" : "zh-cn",
  "wordCount":  23150 ,
  "datePublished" : "2020-08-01T16:29:01",
  "dateModified" : "2020-08-01T16:29:01",
  "image" : "https:\/\/newlooper.win\/images\/site\/avatar-icon.png",
  "keywords" : [ "Assembly Language, NASM, Programming" ],
  "mainEntityOfPage" : "https:\/\/newlooper.win\/post\/trans\/learn-assembly-language\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/newlooper.win",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/newlooper.win\/images\/site\/avatar-icon.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="Learn Assembly Language 汇编语言学习(拙译)" />
<meta property="og:description" content="Index-0 原址：https://asmtutor.com/ 环境：nasm on x64 linux TL;DR 动机：程序员——多掌握几门计算机语言，还是有好处的 主题：汇编语言——">
<meta property="og:image" content="https://newlooper.win/images/site/avatar-icon.png" />
<meta property="og:url" content="https://newlooper.win/post/trans/learn-assembly-language/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Looper 的博客" />

  <meta name="twitter:title" content="Learn Assembly Language 汇编语言学习(拙译)" />
  <meta name="twitter:description" content="Index-0 原址：https://asmtutor.com/ 环境：nasm on x64 linux TL;DR 动机：程序员——多掌握几门计算机语言，还是有好处的 主题：汇编语言——">
  <meta name="twitter:image" content="https://newlooper.win/images/site/avatar-icon.png" />
  <meta name="twitter:card" content="summary" />
  <link href='https://newlooper.win/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.74.3" />
  <link rel="alternate" href="https://newlooper.win/index.xml" type="application/rss+xml" title="Looper 的博客"><link rel="stylesheet" href="https://newlooper.win/css/katex.min.css" />
  <link rel="stylesheet" href="https://newlooper.win/fontawesome/css/all.css" />
  <link rel="stylesheet" href="https://newlooper.win/css/bootstrap.min.css" /><link rel="stylesheet" href="https://newlooper.win/css/main.css" /><link rel="stylesheet" href="https://newlooper.win/css/fonts.css" /><link rel="stylesheet" href="https://newlooper.win/css/syntax.css" /><link rel="stylesheet" href="https://newlooper.win/css/codeblock.css" /><link rel="stylesheet" href="https://newlooper.win/css/photoswipe.min.css" />
  <link rel="stylesheet" href="https://newlooper.win/css/photoswipe.default-skin.min.css" /><style>
.container {
    width: 1500px;
    min-width: 1500px;
}
article.blog-post {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
article.blog-post > blockquote {
    font-family: 'Lora', 'Times New Roman', serif;
}
article.blog-post img {
    display: block;
    margin-top: 1em;
    margin-right: auto;
    margin-bottom: 1em;
    margin-left: auto;
    max-width: 100%;
}
article.blog-post table {
    margin: auto;
    width: 90%;
    margin-bottom: 0.5em;
    box-shadow: 2px 2px 3px rgba(0,0,0,.125);
}
article.blog-post blockquote {
    margin: 1em 0;
    padding: 10px 20px;
    position: relative;
    color: rgba(52,73,94,.8);
    background-color: rgba(248,245,236,.6);
    border-left: 5px solid #eee;
    box-shadow: 1px 1px 2px rgba(0,0,0,.125);
}
aside.toc {
    float: right;
    padding: 6px;
    padding-right: 20px;
    margin: 0;
    margin-left: 10px;
    margin-bottom: 10px;
    border: solid 1px #d3d3d3;
    font-size: 12px;
}

aside.toc ul {
    padding-inline-start: 20px;
    list-style: circle;
}

aside.toc a {
    color: #666;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" 
integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" 
integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

<script>
document.addEventListener("DOMContentLoaded", function() {
	renderMathInElement(document.body, {
		delimiters: [
			{left: "$$", right: "$$", display: true},
			{left: "$", right: "$", display: false}
		]
	});
});
</script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-175169252-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">切换导航</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://newlooper.win">Looper 的博客</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        

        

        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Looper 的博客" href="https://newlooper.win">
            <img class="avatar-img" src="https://newlooper.win/images/site/avatar-icon.png" alt="Looper 的博客" />
          </a>
        </div>
      </div>
    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>Learn Assembly Language 汇编语言学习(拙译)</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 map[Count:2020-08-01]
  
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;23150&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Dylan Cheng
    
  
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <aside class="toc">
          <nav id="TableOfContents">
  <ul>
    <li><a href="#index-0">Index-0</a></li>
    <li><a href="#tldr">TL;DR</a></li>
    <li><a href="#lesson-1-hello-world">Lesson 1 Hello, world!</a></li>
    <li><a href="#lesson-2-程序退出的正确姿势">Lesson 2 程序退出的正确姿势</a></li>
    <li><a href="#lesson-3-计算字符串长度">Lesson 3 计算字符串长度</a></li>
    <li><a href="#lesson-4-子例程">Lesson 4 子例程</a></li>
    <li><a href="#lesson-5-外部包含文件">Lesson 5 外部包含文件</a></li>
    <li><a href="#lesson-6-null-终止符">Lesson 6 NULL 终止符</a></li>
    <li><a href="#lesson-7-换行">Lesson 7 换行</a></li>
    <li><a href="#lesson-8-命令行参数">Lesson 8 命令行参数</a></li>
    <li><a href="#lesson-9-处理用户输出">Lesson 9 处理用户输出</a></li>
    <li><a href="#lesson-10-数到十">Lesson 10 数到十</a></li>
    <li><a href="#lesson-11-数到十-itoa">Lesson 11 数到十 (itoa)</a></li>
    <li><a href="#lesson-12-计算加法">Lesson 12 计算——加法</a></li>
    <li><a href="#lesson-13-计算减法">Lesson 13 计算——减法</a></li>
    <li><a href="#lesson-14-计算乘法">Lesson 14 计算——乘法</a></li>
    <li><a href="#lesson-15-计算除法">Lesson 15 计算——除法</a></li>
    <li><a href="#lesson-16-计算atoi">Lesson 16 计算——atoi</a></li>
    <li><a href="#lesson-17-命名空间">Lesson 17 命名空间</a></li>
    <li><a href="#lesson-18-fizzbuzz-游戏">Lesson 18 FizzBuzz 游戏</a></li>
    <li><a href="#lesson-19-执行命令">Lesson 19 执行命令</a></li>
    <li><a href="#lesson-20-process-forking">Lesson 20 Process Forking</a></li>
    <li><a href="#lesson-21-输出时间">Lesson 21 输出时间</a></li>
    <li><a href="#lesson-22-文件操作create">Lesson 22 文件操作——Create</a></li>
    <li><a href="#lesson-23-文件操作write">Lesson 23 文件操作——Write</a></li>
    <li><a href="#lesson-24-文件操作open">Lesson 24 文件操作——Open</a></li>
    <li><a href="#lesson-25-文件操作read">Lesson 25 文件操作——Read</a></li>
    <li><a href="#lesson-26-文件操作close">Lesson 26 文件操作——Close</a></li>
    <li><a href="#lesson-27-文件操作seek">Lesson 27 文件操作——Seek</a></li>
    <li><a href="#lesson-28-文件操作delete">Lesson 28 文件操作——Delete</a></li>
    <li><a href="#lesson-29-套接字create">Lesson 29 套接字——Create</a></li>
    <li><a href="#lesson-30-套接字bind">Lesson 30 套接字——Bind</a></li>
    <li><a href="#lesson-31-套接字listen">Lesson 31 套接字——Listen</a></li>
    <li><a href="#lesson-32-套接字accept">Lesson 32 套接字——Accept</a></li>
    <li><a href="#lesson-33-套接字read">Lesson 33 套接字——Read</a></li>
    <li><a href="#lesson-34-套接字write">Lesson 34 套接字——Write</a></li>
    <li><a href="#lesson-35-套接字close">Lesson 35 套接字——Close</a></li>
    <li><a href="#lesson-36-套接字下载网页">Lesson 36 套接字——下载网页</a></li>
  </ul>
</nav>
        </aside>
        <h2 id="index-0">Index-0</h2>
<p>原址：https://asmtutor.com/<br>
环境：nasm on x64 linux</p>
<h2 id="tldr">TL;DR</h2>
<ul>
<li>
<p>动机：程序员——多掌握几门计算机语言，还是有好处的</p>
</li>
<li>
<p>主题：汇编语言——有其不可替代的作用</p>
</li>
<li>
<p>呈示：天下语言逾千——汇编笑看沉舟侧畔</p>
</li>
<li>
<p>展开：欲知程序真相——反编译难，反汇编易</p>
</li>
<li>
<p>再现：大道器也不器——初见时如茶味甘苦，洞悉后若灌顶醍醐；原以为听多说多皆已昨，忽回首似曾相识又如陌；罢，风流不在谈峰健，相对无言味更长……</p>
</li>
</ul>
<hr>
<p>原文作者自己说 『<em>This project was put together to teach myself NASM assembly language on linux.</em>』</p>
<p>欸~，原来是很窄众的哦。</p>
<p>写的虽然通俗，但依然能感到其面向的并不是毫无编程基础的人群，所谓“某子不能隐真恶”，无论怎样努力的将大量概念、原理、知识安排到看似聊天般的文字中，这里都要提醒读者注意，提防因为好奇心而陷入递归学习的泥潭……</p>
<hr>
<h2 id="lesson-1-hello-world">Lesson 1 Hello, world!</h2>
<h3 id="背景知识">背景知识</h3>
<p>汇编语言是一种<a href="https://zh.wikipedia.org/wiki/%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80">低级语言</a>，汇编程序员与底层硬件之间唯一的接口只有<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>本身。用汇编语言编程，涉及到 Linux 内核提供的<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a>机制。这些系统调用是操作系统内置的库函数，提供诸如读取键盘输入以及将输出显示到屏幕之类的功能。</p>
<p>当用户程序发起系统调用时，内核将立即<a href="https://zh.wikipedia.org/wiki/%E6%8C%82%E8%B5%B7">挂起</a>该程序，进而通过驱动程序让相关硬件完成用户程序所发起的任务请求，最后，将控制权交还给用户程序。</p>
<blockquote>
<p>注意：驱动程序的驱动二字，形象的描述了内核对硬件的控制</p>
</blockquote>
<p>在汇编语言中发起系统调用，需要向<code>EAX</code><a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>写入相应调用的函数编号(也即：操作码<code>OPCODE</code>)，同时设置其他几个寄存器的值作为实际参数，一切准备停当后，指令<code>INT</code>发送一个软<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7">中断</a>，内核收到中断请求后接受参数并执行相应的库函数。简单直接。</p>
<h3 id="来写我们的第壹个汇编程序吧美玉有瑕">来写我们的第壹个汇编程序吧——美玉有瑕</h3>
<p>还是从著名的例子——$$Hello, world! $$ 开始，我们的汇编程序将把这个让无数程序员产生<code>我已经学会这种语言了</code>的错觉的字符串打印到<a href="https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E4%B8%B2%E6%B5%81#%E6%A8%99%E6%BA%96%E8%BC%B8%E5%87%BA_(stdout)">标准输出</a>上。</p>
<p>首先，在数据段定义一个<code>msg</code>变量，并赋给其一个字符串类型的值作为程序的输出。而在代码段中，通过编写全局标签<code>_start:</code>，告诉内核我们(写的诗)程序开始的地方(没有远方)</p>
<p>实际参数通过以下寄存器传给内核：</p>
<ul>
<li><code>EDX</code>存储字符串的长度(字节数)</li>
<li><code>ECX</code>存储字符串的首地址(定义在数据段中的<code>msg</code>变量加载到内存后所在的位置)</li>
<li><code>EBX</code>存储字符串写操作的目标文件——本例中是<code>STDOUT</code></li>
</ul>
<p>数据类型和实际参数的含义可以在函数定义中查到。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp"># https:</span><span class="c1">//github.com/torvalds/linux/blob/master/include/linux/syscalls.h
</span><span class="c1"></span><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div><p>接下来，编译、链接、运行程序</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Hello World Program - asmtutor.com</span>
<span class="c1">; Compile with: nasm -f elf helloworld.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld</span>
<span class="c1">; Run with: ./helloworld</span>
 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">msg</span>     <span class="nv">db</span>      <span class="s">&#39;Hello World!&#39;</span><span class="p">,</span> <span class="mh">0Ah</span>     <span class="c1">; assign msg variable with your message string</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">13</span>     <span class="c1">; number of bytes to write - one for each letter plus 0Ah (line feed character)</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>    <span class="c1">; move the memory address of our message string into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; write to the STDOUT file</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>      <span class="c1">; invoke SYS_WRITE (kernel opcode 4)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld.asm
$ ld -m elf_i386 helloworld.o -o helloworld
$ ./helloworld
Hello World!
Segmentation fault
</code></pre></div><blockquote>
<p>注意：系统报告了错误——Segmentation fault</p>
</blockquote>
<hr>
<h2 id="lesson-2-程序退出的正确姿势">Lesson 2 程序退出的正确姿势</h2>
<h3 id="若干背景知识">若干背景知识</h3>
<p>让我们从第一课成功发起系统调用的短暂喜悦中回过神来，学习内核中另一个最重要的系统调用<code>sys_exit</code></p>
<p>还记得，上一课中，程序运行并打印了 $$Hello, world!$$ 字符串后，还看到了一句<code>Segmentation fault</code>？</p>
<p>嘛，计算机程序可看作是装载到内存中且被分割成若干节(或段)的一长条的<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4">指令</a>序列，这个通用的内存池实际上被所有程序共享，保存着变量、指令，其他程序等等……每一个段都有一个地址，以便其中存储的二进制信息之后的定位访问。</p>
<p>要执行加载到内存中的程序，我们使用全局标签<code>_start:</code>来告诉操作系统从哪里找到并开始执行我们的程序。从那个位置开始，内存将依据程序的逻辑所决定的下一个地址被依次访问。内核在这些地址上愉悦的跳来跳去，执行着程序。</p>
<p>与告诉内核<strong>一个程序从哪里开始</strong>同样重要的是：<strong>程序在哪里结束</strong>。这正是上一课中的程序所缺少的步骤。因为这个重要步骤的缺失，在调用完<code>sys_write</code>，内核把控制权交还给我们的程序之后，程序继续顺序执行内存中紧挨在<code>int     80h</code>之后的地址中的&quot;指令&rdquo;(天知道那一刻那里存的是啥)，我们不知道内核将执行什么指令，但显然在这个例子中内核噎住了，并且不高兴(非正常)的终止了进程，严肃的招待了我们一个：<code>Segmentation fault</code></p>
<p>在程序的末尾调用<code>sys_exit</code>吧！</p>
<h3 id="开写我们的第贰个汇编程序善始善终">开写我们的第贰个汇编程序——善始善终</h3>
<p><code>sys_exit</code>的定义简单明了。在<a href="http://faculty.nps.edu/cseagle/assembly/sys_call.html">Linux 系统调用表</a>中，操作码<code>OPCODE 1</code>被分配给了她，同时她比<code>sys_write</code>节省一些，调用她只需要传一个参数</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp"># https:</span><span class="c1">//github.com/torvalds/linux/blob/master/include/linux/syscalls.h
</span><span class="c1"></span><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">error_code</span><span class="p">);</span>
</code></pre></div><p>她要被要这样调：</p>
<ul>
<li><code>EBX</code>里存<code>0</code>意为<code>零个错误</code></li>
<li><code>EAX</code>当然就存<code>1</code>了 (sys_exit 的 OPCODE)</li>
<li>然后，软中断<code>INT 80h</code>和上一个例子一样</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Hello World Program - asmtutor.com</span>
<span class="c1">; Compile with: nasm -f elf helloworld.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld</span>
<span class="c1">; Run with: ./helloworld</span>
 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">msg</span>     <span class="nv">db</span>      <span class="s">&#39;Hello World!&#39;</span><span class="p">,</span> <span class="mh">0Ah</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">13</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">0</span>      <span class="c1">; return 0 status on exit - &#39;No Errors&#39;</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; invoke SYS_EXIT (kernel opcode 1)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld.asm
$ ld -m elf_i386 helloworld.o -o helloworld
$ ./helloworld
Hello World!
</code></pre></div><p>$$We\ will\ meet\ again,\ Segmentation\ fault$$</p>
<hr>
<h2 id="lesson-3-计算字符串长度">Lesson 3 计算字符串长度</h2>
<h3 id="又一些背景知识">又一些背景知识</h3>
<p>为什么需要计算字符串的长度？</p>
<p>嘛，<code>sys_write</code>必须知道我们传给她的字符串的指针和长度(字节数)，才能够打印输出。如果修改了<code>msg</code>字符串的内容，也必须相应的更新字符串的长度，否则打印操作将不正确。</p>
<p>为了验证这一点，我们用第二课中的例子。将<code>msg</code>字符串修改为：(中括号帮助标识边界用)
$$[Hello,\ brave\ new\ world!]$$
编译、链接、执行修改后的程序。输出变为：
$$[Hello,\ brave\ ]$$
(仅有前 13 个 ascii 字符，空格也算)，这是因为我们没有将长度实参的值从原来的 13，更新为新字符串长度 23</p>
<h3 id="我们的第叁个汇编程序登场魔尺道丈">我们的第叁个汇编程序登场——魔尺道丈</h3>
<p>要计算某个字符串的长度，这里引入一种称作<a href="https://www.tutorialspoint.com/cprogramming/c_pointer_arithmetic.htm">指针算数</a>的技术。具体步骤为：</p>
<ul>
<li>选两个寄存器初始化为相同的内存地址</li>
<li>用其中一个寄存器(本例中使用<code>EAX</code>)遍历要输出的字符串中的字符，在每次遇到 1 个字符的时候给自己加 1，直到其遇到一个代表字符串结尾的特殊字符</li>
<li>此时用<code>EAX</code>减去一开始初始化为相同值的另一个寄存器的值，结果就是字符的个数</li>
</ul>
<p>有点像两个数组做减法，差表示了两个地址之间的元素的个数。我们用这个差值替代旧例子中的<a href="https://zh.wikipedia.org/wiki/%E5%AF%AB%E6%AD%BB">硬编码</a>值，传递给<code>sys_write</code></p>
<p>汇编程序中，通常用<code>CMP</code>指令进行某种判断，根据其两个操作数的比较结果来置位标志寄存器，后续指令根据标志寄存器的值来决定如何推进程序的流程。</p>
<p>在接下来的代码中，我们关注的是<code>ZF (Zero Flag)</code>标志寄存器。如果<code>EAX</code>寄存器中的地址所指向的字符 ascii 值等于 0，则<code>ZF</code>被置位。而后<code>JZ</code>指令看到<code>ZF</code>为 1，就跳转到其操作数所指明的位置(流程改变)，这个跳转为的是退出 nextchar 循环从而执行后续的程序代码</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Hello World Program (Calculating string length)</span>
<span class="c1">; Compile with: nasm -f elf helloworld-len.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len</span>
<span class="c1">; Run with: ./helloworld-len</span>
 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">msg</span>     <span class="nv">db</span>      <span class="s">&#39;Hello, brave new world!&#39;</span><span class="p">,</span> <span class="mh">0Ah</span> <span class="c1">; we can modify this now without having to update anywhere else in the program</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; move the address of our message string into EBX</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>        <span class="c1">; move the address in EBX into EAX as well (Both now point to the same segment in memory)</span>
 
<span class="nl">nextchar:</span>
    <span class="nf">cmp</span>     <span class="kt">byte</span> <span class="p">[</span><span class="nb">eax</span><span class="p">],</span> <span class="mi">0</span>   <span class="c1">; compare the byte pointed to by EAX at this address against zero (Zero is an end of string delimiter)</span>
    <span class="nf">jz</span>      <span class="nv">finished</span>        <span class="c1">; jump (if the zero flagged has been set) to the point in the code labeled &#39;finished&#39;</span>
    <span class="nf">inc</span>     <span class="nb">eax</span>             <span class="c1">; increment the address in EAX by one byte (if the zero flagged has NOT been set)</span>
    <span class="nf">jmp</span>     <span class="nv">nextchar</span>        <span class="c1">; jump to the point in the code labeled &#39;nextchar&#39;</span>
 
<span class="nl">finished:</span>
    <span class="nf">sub</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>        <span class="c1">; subtract the address in EBX from the address in EAX</span>
                            <span class="c1">; remember both registers started pointing to the same address (see line 15)</span>
                            <span class="c1">; but EAX has been incremented one byte for each character in the message string</span>
                            <span class="c1">; when you subtract one memory address from another of the same type</span>
                            <span class="c1">; the result is number of segments between them - in this case the number of bytes</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; EAX now equals the number of bytes in our string</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; the rest of the code should be familiar now</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-len.asm
$ ld -m elf_i386 helloworld-len.o -o helloworld-len
$ ./helloworld-len
Hello, brave new world!
</code></pre></div><hr>
<h2 id="lesson-4-子例程">Lesson 4 子例程</h2>
<h3 id="引入子例程">引入子例程</h3>
<p>子例程——函数也。他们是可复用的代码片段，能够被用户程序调用完成各种各样的任务。和前面定义程序入口点一样，子例程也通过定义标签来声明其起始位置(如<code>strlen:</code>)，然而不同之处在于程序不使用<code>JMP</code>指令来访问子例程，取而代之的是使用<code>CALL</code>指令。同样，子例程执行完成后的跳转回地址也不使用<code>JMP</code>而是使用<code>RET</code>。</p>
<p>同样是跳转到指令的所在处(memory address)，为什么子例程不使用<code>JMP</code>呢？</p>
<p>子例程的威力在于其可复用性，想在程序中的任意位置随时调用子例程，除了要跳转到子例程所在的地址外，还必须要编写一些逻辑来确定子例程运行完后跳转回的位置，如果使用<code>JMP</code>将导致我们的代码中到处是非必要的标签。而使用<code>CALL</code>和<code>RET</code>，汇编语言将采用称作<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88">堆栈</a>的机制代为处理这些细节。</p>
<h3 id="引入栈">引入栈</h3>
<p>栈也在内存中，然而某个程序的栈内存对其而言具备一些特殊性质。栈内存的存取遵循<a href="https://zh.wikipedia.org/wiki/%E5%85%88%E9%80%B2%E5%85%88%E5%87%BA%E5%92%8C%E5%BE%8C%E9%80%B2%E5%85%88%E5%87%BA%E6%9C%83%E8%A8%88%E6%B3%95">后进先出</a> Last In First Out memory (LIFO)原则。可以将其想象成厨房中的一摞碟子，最后一个放在顶上的碟子也正是下一次用碟子时第一个被取走的。</p>
<p>诚然，汇编中的栈内存放不下碟子，但是能放二进制数据。变量、地址、甚至其他程序都可以放进去。当调用子例程时，我们需要使用栈来临时存放上述数据以便子例程使用。</p>
<p>通常，执行中的一段代码所使用着的任何寄存器，都应该在调用子例程之前，使用<code>PUSH</code>指令将其中的数据压入栈，以此确保子例程返回后可以还原这些寄存器的原有值(因为子例程有可能会使用上述寄存器存储新的数据，不预先保存的话被覆盖后就丢失了)，还原通过与<code>PUSH</code>指令执行顺序相反的顺序执行<code>POP</code>指令来完成。如此，就不必担心子例程执行过程中对上述寄存的修改。</p>
<p><code>CALL</code>和<code>RET</code>两个指令与<code>PUSH</code>和<code>POP</code>相似，也使用到了堆栈，但他们除了压栈/弹栈外还做了额外的工作，当<code>CALL</code>一个子例程时，<code>CALL</code>指令所在位置的下一个内存地址(return address)被压入栈，同时子例程所在地址被存入<code>EIP</code>。这个存在栈内存中的地址(return address)将由在子例程中的<code>RET</code>指令弹给<code>EIP</code>从而跳转回调用者的代码继续执行。希望这段描述能够些许的消除【内联标签使用<code>JMP</code>，而子例程(函数)调用使用<code>CALL</code>】的疑惑。</p>
<h3 id="我们的第肆个汇编程序管中窥豹">我们的第肆个汇编程序——管中窥豹</h3>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Hello World Program (Subroutines)</span>
<span class="c1">; Compile with: nasm -f elf helloworld-len.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len</span>
<span class="c1">; Run with: ./helloworld-len</span>
 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">msg</span>     <span class="nv">db</span>      <span class="s">&#39;Hello, brave new world!&#39;</span><span class="p">,</span> <span class="mh">0Ah</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; move the address of our message string into EAX</span>
    <span class="nf">call</span>    <span class="nv">strlen</span>          <span class="c1">; call our function to calculate the length of the string</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; our function leaves the result in EAX</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; this is all the same as before</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">strlen:</span>                     <span class="c1">; this is our first function declaration</span>
    <span class="nf">push</span>    <span class="nb">ebx</span>             <span class="c1">; push the value in EBX onto the stack to preserve it while we use EBX in this function</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; move the address in EAX into EBX (Both point to the same segment in memory)</span>
 
<span class="nl">nextchar:</span>                   <span class="c1">; this is the same as lesson3</span>
    <span class="nf">cmp</span>     <span class="kt">byte</span> <span class="p">[</span><span class="nb">eax</span><span class="p">],</span> <span class="mi">0</span>
    <span class="nf">jz</span>      <span class="nv">finished</span>
    <span class="nf">inc</span>     <span class="nb">eax</span>
    <span class="nf">jmp</span>     <span class="nv">nextchar</span>
 
<span class="nl">finished:</span>
    <span class="nf">sub</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">pop</span>     <span class="nb">ebx</span>             <span class="c1">; pop the value on the stack back into EBX</span>
    <span class="nf">ret</span>                     <span class="c1">; return to where the function was called</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-len.asm
$ ld -m elf_i386 helloworld-len.o -o helloworld-len
$ ./helloworld-len
Hello, brave new world!
</code></pre></div><hr>
<h2 id="lesson-5-外部包含文件">Lesson 5 外部包含文件</h2>
<p>外部包含文件使得我们能够将程序的代码分散不同文件中。对于撰写清晰、易维护的程序来说这个技术很有用。可重用代码能够写成子例程保存在分散的文件中，这类文件被称为库。当你想使用库中的某段代码时，包含该库文件到你的程序，就好像该文件的内容是就是你程序的一部分一样。</p>
<p>本节我们把计算字符串长度的子例程移到外部文件中。同时，将字符串打印和程序退出逻辑也都修缮为子例程一并移到外部文件里。如此，瘦身后的程序看起来更加清晰、易读。</p>
<p>这里多声明一条消息，调用两次字符串打印子例程来演示对代码的复用。</p>
<blockquote>
<p>注意：之后的课程中，除非 functions.asm 发生了改变，否则其代码将被省略</p>
</blockquote>
<h3 id="我们的第伍个汇编程序他山之石">我们的第伍个汇编程序——他山之石</h3>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">;------------------------------------------</span>
<span class="c1">; functions.asm</span>
<span class="c1">;</span>

<span class="c1">; int slen(String message)</span>
<span class="c1">; String length calculation function</span>
<span class="nl">slen:</span>
    <span class="nf">push</span>    <span class="nb">ebx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>
 
<span class="nl">nextchar:</span>
    <span class="nf">cmp</span>     <span class="kt">byte</span> <span class="p">[</span><span class="nb">eax</span><span class="p">],</span> <span class="mi">0</span>
    <span class="nf">jz</span>      <span class="nv">finished</span>
    <span class="nf">inc</span>     <span class="nb">eax</span>
    <span class="nf">jmp</span>     <span class="nv">nextchar</span>
 
<span class="nl">finished:</span>
    <span class="nf">sub</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">pop</span>     <span class="nb">ebx</span>
    <span class="nf">ret</span>
 
 
<span class="c1">;------------------------------------------</span>
<span class="c1">; void sprint(String message)</span>
<span class="c1">; String printing function</span>
<span class="nl">sprint:</span>
    <span class="nf">push</span>    <span class="nb">edx</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>
    <span class="nf">push</span>    <span class="nb">ebx</span>
    <span class="nf">push</span>    <span class="nb">eax</span>
    <span class="nf">call</span>    <span class="nv">slen</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">pop</span>     <span class="nb">ebx</span>
    <span class="nf">pop</span>     <span class="nb">ecx</span>
    <span class="nf">pop</span>     <span class="nb">edx</span>
    <span class="nf">ret</span>
 
 
<span class="c1">;------------------------------------------</span>
<span class="c1">; void exit()</span>
<span class="c1">; Exit program and restore resources</span>
<span class="nl">quit:</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
    <span class="nf">ret</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Hello World Program (External file include)</span>
<span class="c1">; Compile with: nasm -f elf helloworld-inc.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc</span>
<span class="c1">; Run with: ./helloworld-inc</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;                             </span><span class="c1">; include our external file
</span><span class="c1"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">msg1</span>    <span class="nv">db</span>      <span class="s">&#39;Hello, brave new world!&#39;</span><span class="p">,</span> <span class="mh">0Ah</span>              <span class="c1">; our first message string</span>
<span class="nf">msg2</span>    <span class="nv">db</span>      <span class="s">&#39;This is how we recycle in NASM.&#39;</span><span class="p">,</span> <span class="mh">0Ah</span>      <span class="c1">; our second message string</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg1</span>       <span class="c1">; move the address of our first message string into EAX</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our string printing function</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg2</span>       <span class="c1">; move the address of our second message string into EAX</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our string printing function</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>            <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-inc.asm
$ ld -m elf_i386 helloworld-inc.o -o helloworld-inc
$ ./helloworld-inc
Hello, brave new world!
This is how we recycle in NASM.
This is how we recycle in NASM.
</code></pre></div><blockquote>
<p>错误：貌似第二条消息被打印了两次，我们在下节课修正:-)</p>
</blockquote>
<hr>
<h2 id="lesson-6-null-终止符">Lesson 6 NULL 终止符</h2>
<p>好吧，上一节的结尾我用“貌似”二字修饰了<code>msg2</code>被打印了两次这一现象，实际上程序并没有逻辑错误，她忠实的履行了职责，完成了我们的任务委托，也即：上一节的代码写法，输出就应该是那样子的。解释现象之前，先分别注释掉打印<code>msg1</code>或<code>msg2</code>的代码，只留其中一个看看效果</p>
<p>如果，只注释<code>msg1</code>的打印指令，</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">;   mov     eax, msg1       ; move the address of our first message string into EAX</span>
<span class="c1">;   call    sprint          ; call our string printing function</span>
    
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg2</span>       <span class="c1">; move the address of our second message string into EAX</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our string printing function</span>
</code></pre></div><p>输出为：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">This is how we recycle in NASM.
</code></pre></div><p>输出和我们预期的相符。</p>
<p>如果，只注释<code>msg2</code>的打印指令，</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm">    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg1</span>       <span class="c1">; move the address of our first message string into EAX</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our string printing function</span>
    
<span class="c1">;   mov     eax, msg2       ; move the address of our second message string into EAX</span>
<span class="c1">;   call    sprint          ; call our string printing function</span>
</code></pre></div><p>输出为：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Hello, brave new world!
This is how we recycle in NASM.
</code></pre></div><p>等一下，打印<code>msg1</code>的指令，怎么把第二个字符串也打印了？</p>
<p>答案在于，对于<code>msg1</code>字符串，我们没有给出明确的结尾。在数据段中的两条相邻的<code>db</code>代码，内存的分配也是相邻的，因此，<code>msg1</code>字符串的最后一个字节紧挨着<code>msg2</code>的第一个字节。记得之前，计算字符串长度所采用的方法——通过比较值为 0 的字节作为结尾！Lesson 5 的代码在运行到计算<code>msg1</code>的长度时，子例程读完了所有<code>msg1</code>的字节后，并没有遇到值为 0 的字节，所以她认为这个字符串还没完，程序继续从<code>msg2</code>的第一个字节逐个比较，直到<code>msg2</code>的所有字节也读完了，才找到字符串结尾。</p>
<p>因此看上去<code>msg2</code>被打印两次，实际上是视觉上的问题，实际的输出过程是：</p>
<p>先输出了<code>Hello, brave new world!\nThis is how we recycle in NASM.\n</code>
又输出了<code>This is how we recycle in NASM.\n</code></p>
<p>再等一下，你或许会问，<code>msg2</code>我也没看到有字符串结尾啊？被你逮到了:-)这是因为数据段的内存在开辟时，都被初始化成了 0h。</p>
<h3 id="我们的第陆个汇编程序楚河汉界">我们的第陆个汇编程序——楚河汉界</h3>
<blockquote>
<p>注意：汇编程序中，用 0h 表示 NULL 字节，而 NULL 字节标识了字符串的结尾</p>
</blockquote>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Hello World Program (NULL terminating bytes)</span>
<span class="c1">; Compile with: nasm -f elf helloworld-inc.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc</span>
<span class="c1">; Run with: ./helloworld-inc</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">msg1</span>    <span class="nv">db</span>      <span class="s">&#39;Hello, brave new world!&#39;</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="mh">0h</span>          <span class="c1">; NOTE the null terminating byte</span>
<span class="nf">msg2</span>    <span class="nv">db</span>      <span class="s">&#39;This is how we recycle in NASM.&#39;</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="mh">0h</span>  <span class="c1">; NOTE the null terminating byte</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg1</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg2</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-inc.asm
$ ld -m elf_i386 helloworld-inc.o -o helloworld-inc
$ ./helloworld-inc
Hello, brave new world!
This is how we recycle in NASM.
</code></pre></div><hr>
<h2 id="lesson-7-换行">Lesson 7 换行</h2>
<p>换行的重要性对于控制台程序而言是不言而喻的，尤其是构建需要用户输入的程序时，更是如此。但是换行又是难以摆弄的，处理字符串时有时需要包含换行，有时又需要去掉他。如果始终把表示换行符的 ascii 码 0Ah 硬编码在我们的变量中，就要面对一个问题——在不需要输出换行符的地方得写额外的代码来去掉他。</p>
<p>如果有个专门的子例程输出我们指定的字符串，由该子例程负责在结尾打印一个换行符。就可以在需要打印换行符的地方调用这个子例程，而在不需要打印换行符的地方还使用我们的<code>sprint</code>子例程就可以了。</p>
<p>记得前文中，想调用<code>sys_write</code>必须提供要打印内容的地址及其长度，所以仅仅传递换行符是不够的，同时我们也不想仅仅为了这一个字符单独定义一个变量来保存他，因此使用栈内存来实现新的子例程。</p>
<p>招法如下：</p>
<ul>
<li>换行符存进<code>EAX</code></li>
<li><code>PUSH EAX</code>的值到栈上，并获取<code>ESP</code>的值(当前栈顶所在的地址)</li>
<li>通过当前的<code>ESP</code>知道了换行符所在内存地址，那么调用<code>sys_write</code>的必要条件已然具备</li>
</ul>
<h3 id="且看我们的第柒个汇编程序路转峰回">且看我们的第柒个汇编程序——路转峰回</h3>
<blockquote>
<p>注意：观察 functions.asm 中的 sprintLF 子例程</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">;------------------------------------------</span>
<span class="c1">; int slen(String message)</span>
<span class="c1">; String length calculation function</span>
<span class="nl">slen:</span>
    <span class="nf">push</span>    <span class="nb">ebx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>
 
<span class="nl">nextchar:</span>
    <span class="nf">cmp</span>     <span class="kt">byte</span> <span class="p">[</span><span class="nb">eax</span><span class="p">],</span> <span class="mi">0</span>
    <span class="nf">jz</span>      <span class="nv">finished</span>
    <span class="nf">inc</span>     <span class="nb">eax</span>
    <span class="nf">jmp</span>     <span class="nv">nextchar</span>
 
<span class="nl">finished:</span>
    <span class="nf">sub</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">pop</span>     <span class="nb">ebx</span>
    <span class="nf">ret</span>
 
 
<span class="c1">;------------------------------------------</span>
<span class="c1">; void sprint(String message)</span>
<span class="c1">; String printing function</span>
<span class="nl">sprint:</span>
    <span class="nf">push</span>    <span class="nb">edx</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>
    <span class="nf">push</span>    <span class="nb">ebx</span>
    <span class="nf">push</span>    <span class="nb">eax</span>
    <span class="nf">call</span>    <span class="nv">slen</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">pop</span>     <span class="nb">ebx</span>
    <span class="nf">pop</span>     <span class="nb">ecx</span>
    <span class="nf">pop</span>     <span class="nb">edx</span>
    <span class="nf">ret</span>
 
 
<span class="c1">;------------------------------------------</span>
<span class="c1">; void sprintLF(String message)</span>
<span class="c1">; String printing with line feed function</span>
<span class="nl">sprintLF:</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>
 
    <span class="nf">push</span>    <span class="nb">eax</span>         <span class="c1">; push eax onto the stack to preserve it while we use the eax register in this function</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mh">0Ah</span>    <span class="c1">; move 0Ah into eax - 0Ah is the ascii character for a linefeed</span>
    <span class="nf">push</span>    <span class="nb">eax</span>         <span class="c1">; push the linefeed onto the stack so we can get the address</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">esp</span>    <span class="c1">; move the address of the current stack pointer into eax for sprint</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>      <span class="c1">; call our sprint function</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>         <span class="c1">; remove our linefeed character from the stack</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>         <span class="c1">; restore the original value of eax before our function was called</span>
    <span class="nf">ret</span>                 <span class="c1">; return to our program</span>
 
 
<span class="c1">;------------------------------------------</span>
<span class="c1">; void exit()</span>
<span class="c1">; Exit program and restore resources</span>
<span class="nl">quit:</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
    <span class="nf">ret</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Hello World Program (Print with line feed)</span>
<span class="c1">; Compile with: nasm -f elf helloworld-lf.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-lf.o -o helloworld-lf</span>
<span class="c1">; Run with: ./helloworld-lf</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">msg1</span>    <span class="nv">db</span>      <span class="s">&#39;Hello, brave new world!&#39;</span><span class="p">,</span> <span class="mh">0h</span>          <span class="c1">; NOTE we have removed the line feed character 0Ah</span>
<span class="nf">msg2</span>    <span class="nv">db</span>      <span class="s">&#39;This is how we recycle in NASM.&#39;</span><span class="p">,</span> <span class="mh">0h</span>  <span class="c1">; NOTE we have removed the line feed character 0Ah</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg1</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>    <span class="c1">; NOTE we are calling our new print with linefeed function</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg2</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>    <span class="c1">; NOTE we are calling our new print with linefeed function</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-lf.asm
$ ld -m elf_i386 helloworld-lf.o -o helloworld-lf
$ ./helloworld-lf
Hello, brave new world!
This is how we recycle in NASM.
</code></pre></div><hr>
<h2 id="lesson-8-命令行参数">Lesson 8 命令行参数</h2>
<p>在 NASM 中，接收命令行参数也使用堆栈。程序启动时，所有参数被反序的压入堆栈，然后程序名被压入栈，最后是参数的个数被压入栈。对于 NASM 编写的程序，最顶上的两个栈内存单元总是保存着程序名和参数个数。</p>
<p>要处理这些参数，我们所要做的就是执行若干次<code>POP</code>逐个弹出参数信息，然后迭代每一个参数并运行我们的程序逻辑。在本例中，简单的调用<code>sprintLF</code>函数打印输出。</p>
<blockquote>
<p>注意：我们使用<code>ECX</code>寄存器作为循环计数器。这个通用寄存器最初的设计意图就是计数。</p>
</blockquote>
<h3 id="我们的第捌个汇编程序兵来将挡">我们的第捌个汇编程序——兵来将挡</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Hello World Program (Passing arguments from the command line)</span>
<span class="c1">; Compile with: nasm -f elf helloworld-args.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-args.o -o helloworld-args</span>
<span class="c1">; Run with: ./helloworld-args</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">pop</span>     <span class="nb">ecx</span>             <span class="c1">; first value on the stack is the number of arguments</span>
 
<span class="nl">nextArg:</span>
    <span class="nf">cmp</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mh">0h</span>         <span class="c1">; check to see if we have any arguments left</span>
    <span class="nf">jz</span>      <span class="nv">noMoreArgs</span>      <span class="c1">; if zero flag is set jump to noMoreArgs label (jumping over the end of the loop)</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>             <span class="c1">; pop the next argument off the stack</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>        <span class="c1">; call our print with linefeed function</span>
    <span class="nf">dec</span>     <span class="nb">ecx</span>             <span class="c1">; decrease ecx (number of arguments left) by 1</span>
    <span class="nf">jmp</span>     <span class="nv">nextArg</span>         <span class="c1">; jump to nextArg label</span>
 
<span class="nl">noMoreArgs:</span>
    <span class="nf">call</span>    <span class="nv">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-args.asm
$ ld -m elf_i386 helloworld-lf.o -o helloworld-args
$ ./helloworld-args <span class="s2">&#34;This is one argument&#34;</span> <span class="s2">&#34;This is another&#34;</span> <span class="m">101</span>
./helloworld-args
This is one argument
This is another
<span class="m">101</span>
</code></pre></div><hr>
<h2 id="lesson-9-处理用户输出">Lesson 9 处理用户输出</h2>
<h3 id="引入-bss-段">引入 bss 段</h3>
<p>目前为止，我们用到了代码段<code>.text</code>和数据段<code>.data</code>。接下来引入<code>.bss</code>段——全称 BLOCK Started by Symbol。这块内存用来保存程序中的未初始化变量。这些预留的空间通常用来存储用户输入的数据，这类数据的特点在于无法在编程时知道其具体的大小。</p>
<p>变量声明语法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="k">SECTION</span> <span class="nv">.bss</span>
<span class="nl">variableName1:</span>      <span class="kd">RESB</span>    <span class="mi">1</span>       <span class="c1">; reserve space for 1 byte</span>
<span class="nl">variableName2:</span>      <span class="kd">RESW</span>    <span class="mi">1</span>       <span class="c1">; reserve space for 1 word</span>
<span class="nl">variableName3:</span>      <span class="kd">RESD</span>    <span class="mi">1</span>       <span class="c1">; reserve space for 1 double word</span>
<span class="nl">variableName4:</span>      <span class="kd">RESQ</span>    <span class="mi">1</span>       <span class="c1">; reserve space for 1 double precision float (quad word)</span>
<span class="nl">variableName5:</span>      <span class="kd">REST</span>    <span class="mi">1</span>       <span class="c1">; reserve space for 1 extended precision float</span>
</code></pre></div><p>是时候引入另一个重要的系统调用<code>sys_read</code>了，让用户输入来的更猛烈些吧。在 Linux 系统调用表中，此函数的<code>OPCODE 3</code>。和<code>sys_write</code>一样也接收 3 个参数，详情如下：</p>
<ul>
<li><code>EDX</code>载入读取的最大长度(以字节为单位)</li>
<li><code>ECX</code>载入<code>.bss</code>中创建的变量的地址</li>
<li><code>EBX</code>载入要读取的文件描述符(在本例中为STDIN)</li>
</ul>
<p>同样，函数参数的数据类型和含义可在行数定义中找到</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp"># https:</span><span class="c1">//github.com/torvalds/linux/blob/master/include/linux/syscalls.h
</span><span class="c1"></span><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div><p><code>sys_read</code>的行为：一旦读到一个<code>LF</code>，就返回到调用者程序，此时他至今为止读到的内容被存放在<code>ECX</code>中保存的地址所指向的内存中。</p>
<p>延伸阅读——<a href="../../../post/original/cs/io/eof/">EOF，到底怎么回事</a></p>
<h3 id="这是我们的第玖个汇编程序不预则废">这是我们的第玖个汇编程序——不预则废</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Hello World Program (Getting input)</span>
<span class="c1">; Compile with: nasm -f elf helloworld-input.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-input.o -o helloworld-input</span>
<span class="c1">; Run with: ./helloworld-input</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">msg1</span>        <span class="nv">db</span>      <span class="s">&#39;Please enter your name: &#39;</span><span class="p">,</span> <span class="mh">0h</span>      <span class="c1">; message string asking user for input</span>
<span class="nf">msg2</span>        <span class="nv">db</span>      <span class="s">&#39;Hello, &#39;</span><span class="p">,</span> <span class="mh">0h</span>                       <span class="c1">; message string to use after user has entered their name</span>
 
<span class="k">SECTION</span> <span class="nv">.bss</span>
<span class="nl">sinput:</span>     <span class="kd">resb</span>    <span class="mi">255</span>                                 <span class="c1">; reserve a 255 byte space in memory for the users input string</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg1</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">255</span>        <span class="c1">; number of bytes to read</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">si</span><span class="nv">nput</span>     <span class="c1">; reserved space to store our input (known as a buffer)</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; read from the STDIN file</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">3</span>          <span class="c1">; invoke SYS_READ (kernel opcode 3)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg2</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">si</span><span class="nv">nput</span>     <span class="c1">; move our buffer into eax (Note: input contains a linefeed)</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our print function</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-input.asm
$ ld -m elf_i386 helloworld-input.o -o helloworld-input
$ ./helloworld-input
Please enter your name: Daniel Givney
Hello, Daniel Givney
</code></pre></div><hr>
<h2 id="lesson-10-数到十">Lesson 10 数到十</h2>
<h3 id="又来了背景知识">又来了，背景知识</h3>
<p>与直觉上相反，在汇编语言中计数并不那么简单直接。首先，我们得传递一个地址给<code>sys_write</code>，不能仅仅将数字加载到寄存器中并调用我们的<code>print</code>函数。其次，数字和字符串在汇编里大不相同。字符串被描述为一系列的 ASCII 值。这里有一个关于 <a href="http://www.asciitable.com/">ASCII</a> 的一个不错的站点(怎么打开净是广告。。。) ，这套编码被用来规范跨计算机的字符串表示的统一标准。</p>
<p>Remember，<code>数</code>是无法打印的——打印出来的都是<code>字符串</code>。为了数到 10，需要从标准的整数到对应的 ASCII 字符串的转换。看过 ASCII 码表之后，可以注意到，整数 1 对应的 ASCII 值是 49。实际上，对于 0 到 9 这 10 个整数，加 48 就是其对应的 ASCII 码。</p>
<h3 id="我们的第拾个汇编程序邯郸学步">我们的第拾个汇编程序——邯郸学步</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Hello World Program (Count to 10)</span>
<span class="c1">; Compile with: nasm -f elf helloworld-10.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-10.o -o helloworld-10</span>
<span class="c1">; Run with: ./helloworld-10</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; ecx is initalised to zero.</span>
 
<span class="nl">nextNumber:</span>
    <span class="nf">inc</span>     <span class="nb">ecx</span>             <span class="c1">; increment ecx</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ecx</span>        <span class="c1">; move the address of our integer into eax</span>
    <span class="nf">add</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">48</span>         <span class="c1">; add 48 to our number to convert from integer to ascii for printing</span>
    <span class="nf">push</span>    <span class="nb">eax</span>             <span class="c1">; push eax to the stack</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">esp</span>        <span class="c1">; get the address of the character on the stack</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>        <span class="c1">; call our print function</span>
 
    <span class="nf">pop</span>     <span class="nb">eax</span>             <span class="c1">; clean up the stack so we don&#39;t have unneeded bytes taking up space</span>
    <span class="nf">cmp</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">10</span>         <span class="c1">; have we reached 10 yet? compare our counter with decimal 10</span>
    <span class="nf">jne</span>     <span class="nv">nextNumber</span>      <span class="c1">; jump if not equal and keep counting</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-10.asm
$ ld -m elf_i386 helloworld-10.o -o helloworld-10
$ ./helloworld-10
<span class="m">1</span>
<span class="m">2</span>
<span class="m">3</span>
<span class="m">4</span>
<span class="m">5</span>
<span class="m">6</span>
<span class="m">7</span>
<span class="m">8</span>
<span class="m">9</span>
:
</code></pre></div><blockquote>
<p>哦噢：我们的数字 10 打印成了冒号(:)，咋了呢？</p>
</blockquote>
<hr>
<h2 id="lesson-11-数到十-itoa">Lesson 11 数到十 (itoa)</h2>
<blockquote>
<p>是 itoa，不是 iota</p>
</blockquote>
<p>为什么 Lesson 10 的程序把 10 打印成了冒号(:)呢。嗯，让我们翻开 ASCII 表，能够看到冒号的 ASCII 值是 58 = 10 + 48，所以按上节的程序写法，就应该输出冒号并没有错。上节所说的 0 到 9 这 10 个整数，可以加 48 得到对应的 ASCII 值，然后传给<code>sys_write</code>的输出对应的字符串；但是对于数字 10，他有两位，没有一个单独的 ASCII 来表示 10 的字符串形式。这个两位数需要两个 ASCII，一个表示 1，一个表示 0。因此，传给<code>sys_write</code>一个'4948&rsquo;才是数字 10 的正确字符串形式。10 直接加 48 不行，我们需要把数字的每一位除以 10 后逐个转换</p>
<p>这里引入两个新的子例程，<code>iprint</code>和<code>iprintLF</code>。这些函数用来打印数字的字符串形式，数值本身使用<code>EAX</code>装载，<code>ECX</code>用来计数。然后重复除以 10 的过程，每次把余数加 48，结果值<code>PUSH</code>到栈上以备后用。当除以 10 的商(存在<code>EAX</code>里)为 0 时，将退出当前循环，进入另一个循环。在该循环里我们通过逐个<code>POP</code>弹栈的方法，打印每一位数字的字符串形式。弹到什么时候为止呢？这正是我们在<code>ECX</code>寄存器里存计数的目的，每弹一个值<code>ECX</code>就减 1，直到减到 0。所有的这些都完成后，程序退出。</p>
<p><strong>除法指令简介</strong></p>
<p><code>DIV</code>和<code>IDIV</code>指令将<code>EAX</code>中的值做为被除数，除以指令的原操作数，商的部分存到<code>EAX</code>(覆盖了原来的被除数)而余数部分存在<code>EDX</code>中。(作者写的挺简单，实现上复杂的多：不同位数的策略；高位存什么、低位存什么；有符号、无符号的区别等等。)</p>
<p>比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">10</span>         <span class="c1">; move 10 into eax</span>
<span class="nf">mov</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mi">10</span>         <span class="c1">; move 10 into esi</span>
<span class="nf">idiv</span>    <span class="nb">esi</span>             <span class="c1">; divide eax by esi (eax will equal 1 and edx will equal 0)</span>
<span class="nf">idiv</span>    <span class="nb">esi</span>             <span class="c1">; divide eax by esi again (eax will equal 0 and edx will equal 1)</span>
</code></pre></div><p><strong>只存余数，感觉会有问题？</strong></p>
<p>不会，因为这些都是整数。即便除数比被除数大，依然能够在余数中找到其原值，这是因为在这种情况下<code>EAX</code>置 0，除法运算运行了 0 次，而被除数的原值作为余数被放到了<code>EDX</code>中。真好~</p>
<h3 id="我们的第拾壹个汇编程序知之非艰">我们的第拾壹个汇编程序——知之非艰</h3>
<blockquote>
<p>注意：仅列出了新函数的注释</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">;------------------------------------------</span>
<span class="c1">; void iprint(Integer number)</span>
<span class="c1">; Integer printing function (itoa)</span>
<span class="nl">iprint:</span>
    <span class="nf">push</span>    <span class="nb">eax</span>             <span class="c1">; preserve eax on the stack to be restored after function runs</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>             <span class="c1">; preserve ecx on the stack to be restored after function runs</span>
    <span class="nf">push</span>    <span class="nb">edx</span>             <span class="c1">; preserve edx on the stack to be restored after function runs</span>
    <span class="nf">push</span>    <span class="nb">esi</span>             <span class="c1">; preserve esi on the stack to be restored after function runs</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; counter of how many bytes we need to print in the end</span>
 
<span class="nl">divideLoop:</span>
    <span class="nf">inc</span>     <span class="nb">ecx</span>             <span class="c1">; count each byte to print - number of characters</span>
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; empty edx</span>
    <span class="nf">mov</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mi">10</span>         <span class="c1">; mov 10 into esi</span>
    <span class="nf">idiv</span>    <span class="nb">esi</span>             <span class="c1">; divide eax by esi</span>
    <span class="nf">add</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">48</span>         <span class="c1">; convert edx to it&#39;s ascii representation - edx holds the remainder after a divide instruction</span>
    <span class="nf">push</span>    <span class="nb">edx</span>             <span class="c1">; push edx (string representation of an intger) onto the stack</span>
    <span class="nf">cmp</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; can the integer be divided anymore?</span>
    <span class="nf">jnz</span>     <span class="nb">di</span><span class="nv">videLoop</span>      <span class="c1">; jump if not zero to the label divideLoop</span>
 
<span class="nl">printLoop:</span>
    <span class="nf">dec</span>     <span class="nb">ecx</span>             <span class="c1">; count down each byte that we put on the stack</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">esp</span>        <span class="c1">; mov the stack pointer into eax for printing</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our string print function</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>             <span class="c1">; remove last character from the stack to move esp forward</span>
    <span class="nf">cmp</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; have we printed all bytes we pushed onto the stack?</span>
    <span class="nf">jnz</span>     <span class="nv">printLoop</span>       <span class="c1">; jump is not zero to the label printLoop</span>
 
    <span class="nf">pop</span>     <span class="nb">esi</span>             <span class="c1">; restore esi from the value we pushed onto the stack at the start</span>
    <span class="nf">pop</span>     <span class="nb">edx</span>             <span class="c1">; restore edx from the value we pushed onto the stack at the start</span>
    <span class="nf">pop</span>     <span class="nb">ecx</span>             <span class="c1">; restore ecx from the value we pushed onto the stack at the start</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>             <span class="c1">; restore eax from the value we pushed onto the stack at the start</span>
    <span class="nf">ret</span>
 
 
<span class="c1">;------------------------------------------</span>
<span class="c1">; void iprintLF(Integer number)</span>
<span class="c1">; Integer printing function with linefeed (itoa)</span>
<span class="nl">iprintLF:</span>
    <span class="nf">call</span>    <span class="nv">iprint</span>          <span class="c1">; call our integer printing function</span>
 
    <span class="nf">push</span>    <span class="nb">eax</span>             <span class="c1">; push eax onto the stack to preserve it while we use the eax register in this function</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mh">0Ah</span>        <span class="c1">; move 0Ah into eax - 0Ah is the ascii character for a linefeed</span>
    <span class="nf">push</span>    <span class="nb">eax</span>             <span class="c1">; push the linefeed onto the stack so we can get the address</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">esp</span>        <span class="c1">; move the address of the current stack pointer into eax for sprint</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our sprint function</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>             <span class="c1">; remove our linefeed character from the stack</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>             <span class="c1">; restore the original value of eax before our function was called</span>
    <span class="nf">ret</span>
 
 
<span class="c1">;------------------------------------------</span>
<span class="c1">; int slen(String message)</span>
<span class="c1">; String length calculation function</span>
<span class="nl">slen:</span>
    <span class="nf">push</span>    <span class="nb">ebx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>
 
<span class="nl">nextchar:</span>
    <span class="nf">cmp</span>     <span class="kt">byte</span> <span class="p">[</span><span class="nb">eax</span><span class="p">],</span> <span class="mi">0</span>
    <span class="nf">jz</span>      <span class="nv">finished</span>
    <span class="nf">inc</span>     <span class="nb">eax</span>
    <span class="nf">jmp</span>     <span class="nv">nextchar</span>
 
<span class="nl">finished:</span>
    <span class="nf">sub</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">pop</span>     <span class="nb">ebx</span>
    <span class="nf">ret</span>
 
 
<span class="c1">;------------------------------------------</span>
<span class="c1">; void sprint(String message)</span>
<span class="c1">; String printing function</span>
<span class="nl">sprint:</span>
    <span class="nf">push</span>    <span class="nb">edx</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>
    <span class="nf">push</span>    <span class="nb">ebx</span>
    <span class="nf">push</span>    <span class="nb">eax</span>
    <span class="nf">call</span>    <span class="nv">slen</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">pop</span>     <span class="nb">ebx</span>
    <span class="nf">pop</span>     <span class="nb">ecx</span>
    <span class="nf">pop</span>     <span class="nb">edx</span>
    <span class="nf">ret</span>
 
 
<span class="c1">;------------------------------------------</span>
<span class="c1">; void sprintLF(String message)</span>
<span class="c1">; String printing with line feed function</span>
<span class="nl">sprintLF:</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>
 
    <span class="nf">push</span>    <span class="nb">eax</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mh">0AH</span>
    <span class="nf">push</span>    <span class="nb">eax</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>
    <span class="nf">ret</span>
 
 
<span class="c1">;------------------------------------------</span>
<span class="c1">; void exit()</span>
<span class="c1">; Exit program and restore resources</span>
<span class="nl">quit:</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
    <span class="nf">ret</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Hello World Program (Count to 10 itoa)</span>
<span class="c1">; Compile with: nasm -f elf helloworld-itoa.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-itoa.o -o helloworld-itoa</span>
<span class="c1">; Run with: ./helloworld-itoa</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>
 
<span class="nl">nextNumber:</span>
    <span class="nf">inc</span>     <span class="nb">ecx</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ecx</span>
    <span class="nf">call</span>    <span class="nv">iprintLF</span>        <span class="c1">; NOTE call our new integer printing function (itoa)</span>
    <span class="nf">cmp</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">10</span>
    <span class="nf">jne</span>     <span class="nv">nextNumber</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-itoa.asm
$ ld -m elf_i386 helloworld-itoa.o -o helloworld-itoa
$ ./helloworld-itoa
<span class="m">1</span>
<span class="m">2</span>
<span class="m">3</span>
<span class="m">4</span>
<span class="m">5</span>
<span class="m">6</span>
<span class="m">7</span>
<span class="m">8</span>
<span class="m">9</span>
<span class="m">10</span>
</code></pre></div><hr>
<h2 id="lesson-12-计算加法">Lesson 12 计算——加法</h2>
<p>这次的程序，将寄存器<code>EAX</code>和<code>EBX</code>中的值相加，和保存在<code>EAX</code>中。首先<code>MOV</code>其中一个加数到<code>EAX</code>(本例中为 90)，然后<code>MOV</code>另一个加数到<code>EBX</code>(本例中为9)。我们需要调用<code>ADD</code>指令来实现加法运算。<code>EBX</code>和<code>EAX</code>中的值将被加到一起，而结果和将被存回指令最左边的寄存器中(也就是本例的<code>EAX</code>)。最后调用我们引以为傲的<code>数值-&gt;字符串</code>打印函数来完成程序。</p>
<h3 id="我们的第拾贰个汇编程序聚沙成塔">我们的第拾贰个汇编程序——聚沙成塔</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Calculator (Addition)</span>
<span class="c1">; Compile with: nasm -f elf calculator-addition.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-addition.o -o calculator-addition</span>
<span class="c1">; Run with: ./calculator-addition</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">90</span>     <span class="c1">; move our first number into eax</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">9</span>      <span class="c1">; move our second number into ebx</span>
    <span class="nf">add</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>    <span class="c1">; add ebx to eax</span>
    <span class="nf">call</span>    <span class="nv">iprintLF</span>    <span class="c1">; call our integer print with linefeed function</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf calculator-addition.asm
$ ld -m elf_i386 calculator-addition.o -o calculator-addition
$ ./calculator-addition
<span class="m">99</span>
</code></pre></div><hr>
<h2 id="lesson-13-计算减法">Lesson 13 计算——减法</h2>
<p>这个程序与 Lesson 12 的唯一区别就是加法指令<code>ADD</code>，换成了减法指令<code>SUB</code></p>
<h3 id="我们的第拾叁个汇编程序红衰翠减">我们的第拾叁个汇编程序——红衰翠减</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Calculator (Subtraction)</span>
<span class="c1">; Compile with: nasm -f elf calculator-subtraction.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-subtraction.o -o calculator-subtraction</span>
<span class="c1">; Run with: ./calculator-subtraction</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">90</span>     <span class="c1">; move our first number into eax</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">9</span>      <span class="c1">; move our second number into ebx</span>
    <span class="nf">sub</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>    <span class="c1">; subtract ebx from eax</span>
    <span class="nf">call</span>    <span class="nv">iprintLF</span>    <span class="c1">; call our integer print with linefeed function</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf calculator-subtraction.asm
$ ld -m elf_i386 calculator-subtraction.o -o calculator-subtraction
$ ./calculator-subtraction
<span class="m">81</span>
</code></pre></div><hr>
<h2 id="lesson-14-计算乘法">Lesson 14 计算——乘法</h2>
<p>在本程序中，我们将用<code>EBX</code>中的值与<code>EAX</code>中的值相乘。两个整数按照和 Lesson 12 一样的方式分别存入两个寄存器。这次的指令主角是<code>MUL</code>，他是 NASM 中为数不多的几个单操作数指令之一。<code>MUL</code>指令总是将其操作数与EAX中的值相乘，并将积存回<code>EAX</code></p>
<h3 id="我们的第拾肆个汇编程序一登龙门">我们的第拾肆个汇编程序——一登龙门</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Calculator (Multiplication)</span>
<span class="c1">; Compile with: nasm -f elf calculator-multiplication.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-multiplication.o -o calculator-multiplication</span>
<span class="c1">; Run with: ./calculator-multiplication</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">90</span>     <span class="c1">; move our first number into eax</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">9</span>      <span class="c1">; move our second number into ebx</span>
    <span class="nf">mul</span>     <span class="nb">ebx</span>         <span class="c1">; multiply eax by ebx</span>
    <span class="nf">call</span>    <span class="nv">iprintLF</span>    <span class="c1">; call our integer print with linefeed function</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf calculator-multiplication.asm
$ ld -m elf_i386 calculator-multiplication.o -o calculator-multiplication
$ ./calculator-multiplication
<span class="m">810</span>
</code></pre></div><hr>
<h2 id="lesson-15-计算除法">Lesson 15 计算——除法</h2>
<p>除法指令我们已经见识过了，我们曾用他来实现数字值到 ASCII 码的转换。本例中，依然使用<code>EAX</code>和<code>EBX</code>。他们分别保存被除数和除数。如前所述，<code>DIV</code>指令的行为如下：用其操作数去除<code>EAX</code>中的值，商保存到<code>EAX</code>，而余数保存到<code>EDX</code>。最后将商和余数都打印出来</p>
<h3 id="又见除法的第拾伍个汇编程序经分之术">又见除法的第拾伍个汇编程序——经分之术</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Calculator (Division)</span>
<span class="c1">; Compile with: nasm -f elf calculator-division.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-division.o -o calculator-division</span>
<span class="c1">; Run with: ./calculator-division</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">msg1</span>        <span class="nv">db</span>      <span class="s">&#39; remainder &#39;</span>      <span class="c1">; a message string to correctly output result</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">90</span>     <span class="c1">; move our first number into eax</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">9</span>      <span class="c1">; move our second number into ebx</span>
    <span class="nf">div</span>     <span class="nb">ebx</span>         <span class="c1">; divide eax by ebx</span>
    <span class="nf">call</span>    <span class="nv">iprint</span>      <span class="c1">; call our integer print function on the quotient</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg1</span>   <span class="c1">; move our message string into eax</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>      <span class="c1">; call our string print function</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">edx</span>    <span class="c1">; move our remainder into eax</span>
    <span class="nf">call</span>    <span class="nv">iprintLF</span>    <span class="c1">; call our integer printing with linefeed function</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf calculator-division.asm
$ ld -m elf_i386 calculator-division.o -o calculator-division
$ ./calculator-division
<span class="m">10</span> remainder <span class="m">0</span>
</code></pre></div><hr>
<h2 id="lesson-16-计算atoi">Lesson 16 计算——atoi</h2>
<p>将算数运算中的数值写死在代码里并不激动人心，这次我们要从命令行参数中动态获取变化的数值！</p>
<p><strong>程序步骤</strong></p>
<ul>
<li>我们先用<code>POP</code>从栈上获得命令行参数的个数，并保存在<code>ECX</code>寄存器；然后继续<code>POP</code>出命令的名称，从<code>ECX</code>中去掉他的计数；随后循环的弹出每个参数并执行加法逻辑。</li>
<li>和输出一样，输入给我们的也都是字符串。在进行加法运算前，需要一个和输出时相反的转换操作：ASCII 码-&gt;数字值，没有这个步骤加法的结果将不正确。</li>
<li>这个转换操作由引入的子例程 Ascii to Integer(atoi) 来完成。这个函数将 ASCII 码值对应的数字保存在<code>EAX</code>寄存器。每次我们都把<code>EAX</code>的值加到<code>EDX</code>里去。如果传递给我们的 ASCII 码不是表示 0-9 那是个数字的，就用 0 替代他。</li>
<li>所有参数都经过转换并加到一起后，打印和并退出</li>
</ul>
<p><strong>atoi 原理</strong></p>
<p>将 ASCII 码转为整数并非易事。还记得我们之前是怎么把整数转成 ASCII 码的？现在然要进行其逆运算。</p>
<p>首先，将字符串的地址移入<code>ESI</code>(著名的源址寄存器)；然后，逐字节的遍历字符串(试着将每个字节看做是一个数字或十进制位)。对于每个数字，检测其值是否介于 48 到 57 之间( 0-9 的 ASCII 码)，如果满足条件，就执行以下逻辑：</p>
<p>码值减去 48——得到该码值所表示的数字的十进制整数值，这个值存入<code>EAX</code>，然后<code>EAX</code>乘以 10，随着循环的进行，每一位的位权都在随着乘以 10 而提升，从而归到其所占的位上。</p>
<p>当所有的字节都按照上面的逻辑处理完成，返回结果值之前，还要进入最后的一步：由于最后一位数字是个位数，他不应该乘以 10，但面的逻辑却这样做了。我们需要简单的除以一次 10 来纠正这个错误。当然，如果传递给程序的参数不是整数，这个除法操作就省略掉。</p>
<p><strong>接下来的程序中使用了 BL 寄存器，这里简单说下</strong></p>
<p>通用寄存器的个数就没怎么变过，但是其位数却一扩再扩以提高CPU的计算能力。汇编指令中写<code>BL</code>的意思是，使用32位<code>EBX</code>寄存器的<code>低8位</code>，因为单个 ASCII 码值只需要一个字节就可以放下。如果使用整个32位寄存器来存储这一个字节的数据，那么其中的24位都对我们毫无意义。</p>
<p>对于<code>EBX</code>，其<code>0-16bits</code>段称为<code>BX</code>，而<code>BX</code>则包含<code>BL</code>和<code>BH</code>(低8位，高8位)，显然我们只需要<code>BL</code>。</p>
<p>正向的学习汇编，往往从头开始捣寄存器的历史，名称的含义和位的大小等等。本教程是反向的，通过程序中用到的必要元素来追溯关键的概念和原理。完整的寄存器知识超出了本教程的范围，但之后的篇章将继续讨论，毕竟写汇编嘛，我们绕不过寄存器去 :-)</p>
<h3 id="欢迎我们的第拾陆个汇编程序反朴归真">欢迎我们的第拾陆个汇编程序——反朴归真</h3>
<blockquote>
<p>注意：funcitons.asm 只列出了新引入的 atoi 子例程的代码</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">;------------------------------------------</span>
<span class="c1">; int atoi(Integer number)</span>
<span class="c1">; Ascii to integer function (atoi)</span>
<span class="nl">atoi:</span>
    <span class="nf">push</span>    <span class="nb">ebx</span>             <span class="c1">; preserve ebx on the stack to be restored after function runs</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>             <span class="c1">; preserve ecx on the stack to be restored after function runs</span>
    <span class="nf">push</span>    <span class="nb">edx</span>             <span class="c1">; preserve edx on the stack to be restored after function runs</span>
    <span class="nf">push</span>    <span class="nb">esi</span>             <span class="c1">; preserve esi on the stack to be restored after function runs</span>
    <span class="nf">mov</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; move pointer in eax into esi (our number to convert)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; initialise eax with decimal value 0</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; initialise ecx with decimal value 0</span>
 
<span class="nl">.multiplyLoop:</span>
    <span class="nf">xor</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>        <span class="c1">; resets both lower and uppper bytes of ebx to be 0</span>
    <span class="nf">mov</span>     <span class="nb">bl</span><span class="p">,</span> <span class="p">[</span><span class="nb">esi</span><span class="o">+</span><span class="nb">ecx</span><span class="p">]</span>   <span class="c1">; move a single byte into ebx register&#39;s lower half</span>
    <span class="nf">cmp</span>     <span class="nb">bl</span><span class="p">,</span> <span class="mi">48</span>          <span class="c1">; compare ebx register&#39;s lower half value against ascii value 48 (char value 0)</span>
    <span class="nf">jl</span>      <span class="nv">.finished</span>       <span class="c1">; jump if less than to label finished</span>
    <span class="nf">cmp</span>     <span class="nb">bl</span><span class="p">,</span> <span class="mi">57</span>          <span class="c1">; compare ebx register&#39;s lower half value against ascii value 57 (char value 9)</span>
    <span class="nf">jg</span>      <span class="nv">.finished</span>       <span class="c1">; jump if greater than to label finished</span>
 
    <span class="nf">sub</span>     <span class="nb">bl</span><span class="p">,</span> <span class="mi">48</span>          <span class="c1">; convert ebx register&#39;s lower half to decimal representation of ascii value</span>
    <span class="nf">add</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>        <span class="c1">; add ebx to our interger value in eax</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">10</span>         <span class="c1">; move decimal value 10 into ebx</span>
    <span class="nf">mul</span>     <span class="nb">ebx</span>             <span class="c1">; multiply eax by ebx to get place value</span>
    <span class="nf">inc</span>     <span class="nb">ecx</span>             <span class="c1">; increment ecx (our counter register)</span>
    <span class="nf">jmp</span>     <span class="nv">.multiplyLoop</span>   <span class="c1">; continue multiply loop</span>
 
<span class="nl">.finished:</span>
    <span class="nf">cmp</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; compare ecx register&#39;s value against decimal 0 (our counter register)</span>
    <span class="nf">je</span>      <span class="nv">.restore</span>        <span class="c1">; jump if equal to 0 (no integer arguments were passed to atoi)</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">10</span>         <span class="c1">; move decimal value 10 into ebx</span>
    <span class="nf">div</span>     <span class="nb">ebx</span>             <span class="c1">; divide eax by value in ebx (in this case 10)</span>
 
<span class="nl">.restore:</span>
    <span class="nf">pop</span>     <span class="nb">esi</span>             <span class="c1">; restore esi from the value we pushed onto the stack at the start</span>
    <span class="nf">pop</span>     <span class="nb">edx</span>             <span class="c1">; restore edx from the value we pushed onto the stack at the start</span>
    <span class="nf">pop</span>     <span class="nb">ecx</span>             <span class="c1">; restore ecx from the value we pushed onto the stack at the start</span>
    <span class="nf">pop</span>     <span class="nb">ebx</span>             <span class="c1">; restore ebx from the value we pushed onto the stack at the start</span>
    <span class="nf">ret</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Calculator (ATOI)</span>
<span class="c1">; Compile with: nasm -f elf calculator-atoi.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-atoi.o -o calculator-atoi</span>
<span class="c1">; Run with: ./calculator-atoi 20 1000 317</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">pop</span>     <span class="nb">ecx</span>             <span class="c1">; first value on the stack is the number of arguments</span>
    <span class="nf">pop</span>     <span class="nb">edx</span>             <span class="c1">; second value on the stack is the program name (discarded when we initialise edx)</span>
    <span class="nf">sub</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">1</span>          <span class="c1">; decrease ecx by 1 (number of arguments without program name)</span>
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; initialise our data register to store additions</span>
 
<span class="nl">nextArg:</span>
    <span class="nf">cmp</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mh">0h</span>         <span class="c1">; check to see if we have any arguments left</span>
    <span class="nf">jz</span>      <span class="nv">noMoreArgs</span>      <span class="c1">; if zero flag is set jump to noMoreArgs label (jumping over the end of the loop)</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>             <span class="c1">; pop the next argument off the stack</span>
    <span class="nf">call</span>    <span class="nv">atoi</span>            <span class="c1">; convert our ascii string to decimal integer</span>
    <span class="nf">add</span>     <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; perform our addition logic</span>
    <span class="nf">dec</span>     <span class="nb">ecx</span>             <span class="c1">; decrease ecx (number of arguments left) by 1</span>
    <span class="nf">jmp</span>     <span class="nv">nextArg</span>         <span class="c1">; jump to nextArg label</span>
 
<span class="nl">noMoreArgs:</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">edx</span>        <span class="c1">; move our data result into eax for printing</span>
    <span class="nf">call</span>    <span class="nv">iprintLF</span>        <span class="c1">; call our integer printing with linefeed function</span>
    <span class="nf">call</span>    <span class="nv">quit</span>            <span class="c1">; call our q</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf calculator-atoi.asm
$ ld -m elf_i386 calculator-atoi.o -o calculator-atoi
$ ./calculator-atoi <span class="m">20</span> <span class="m">1000</span> <span class="m">317</span>
<span class="m">1337</span>
</code></pre></div><hr>
<h2 id="lesson-17-命名空间">Lesson 17 命名空间</h2>
<p>对于任何包含大量代码库的软件项目，命名空间都是不可或缺的构造。命名空间为标识符引入作用域的概念，使得重用命名约定成为可能，同时增强了代码的可读性和可维护性。在汇编语言中，全局标签标识子例程，而局部标签用来实现命名空间。</p>
<p>之前的教程中，我们都只使用了全局标签。这意味着即便是实现相同逻辑的代码块，也必须有全局唯一的标签名，前面的<code>finished</code>标签就是一例。同属一个全局作用域，意味着当在一个函数中需要跳出循环时，直接<code>JMP</code>到该函数中的<code>finished</code>标签就行。然而，如果需要从另一个函数中跳出循环，和<code>finished</code>代码块功能相同的代码就得改名。我们希望能重用<code>finished</code>这个名字，因为他能向代码的阅读者暗示出某种已知的逻辑。</p>
<p>局部标签以<code>.</code>开头，比如：<code>.finished</code>。随着 functions.asm 的不断扩展，你可能已经注意到他的出现了。一个局部标签的命名空间，由离他最近的前面的一个全局标签限定。你可以使用<code>JMP</code>跳转到局部标签，编译器将通过当前调用的作用域(基于其之上的全局标签)计算出应该引用哪一个局部标签。</p>
<h3 id="第拾柒个汇编程序各安生业">第拾柒个汇编程序——各安生业</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Namespace</span>
<span class="c1">; Compile with: nasm -f elf namespace.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 namespace.o -o namespace</span>
<span class="c1">; Run with: ./namespace</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">msg1</span>        <span class="nv">db</span>      <span class="s">&#39;Jumping to finished label.&#39;</span><span class="p">,</span> <span class="mh">0h</span>        <span class="c1">; a message string</span>
<span class="nf">msg2</span>        <span class="nv">db</span>      <span class="s">&#39;Inside subroutine number: &#39;</span><span class="p">,</span> <span class="mh">0h</span>        <span class="c1">; a message string</span>
<span class="nf">msg3</span>        <span class="nv">db</span>      <span class="s">&#39;Inside subroutine &#34;finished&#34;.&#39;</span><span class="p">,</span> <span class="mh">0h</span>     <span class="c1">; a message string</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
<span class="nl">subrountineOne:</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg1</span>       <span class="c1">; move the address of msg1 into eax</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>        <span class="c1">; call our string printing with linefeed function</span>
    <span class="nf">jmp</span>     <span class="nv">.finished</span>       <span class="c1">; jump to the local label under the subrountineOne scope</span>
 
<span class="nl">.finished:</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg2</span>       <span class="c1">; move the address of msg2 into eax</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our string printing function</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>          <span class="c1">; move the value one into eax (for subroutine number one)</span>
    <span class="nf">call</span>    <span class="nv">iprintLF</span>        <span class="c1">; call our integer printing function with linefeed function</span>
 
<span class="nl">subrountineTwo:</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg1</span>       <span class="c1">; move the address of msg1 into eax</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>        <span class="c1">; call our string print with linefeed function</span>
    <span class="nf">jmp</span>     <span class="nv">.finished</span>       <span class="c1">; jump to the local label under the subrountineTwo scope</span>
 
<span class="nl">.finished:</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg2</span>       <span class="c1">; move the address of msg2 into eax</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our string printing function</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">2</span>          <span class="c1">; move the value two into eax (for subroutine number two)</span>
    <span class="nf">call</span>    <span class="nv">iprintLF</span>        <span class="c1">; call our integer printing function with linefeed function</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg1</span>       <span class="c1">; move the address of msg1 into eax</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>        <span class="c1">; call our string printing with linefeed function</span>
    <span class="nf">jmp</span>     <span class="nv">finished</span>        <span class="c1">; jump to the global label finished</span>
 
<span class="nl">finished:</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg3</span>       <span class="c1">; move the address of msg3 into eax</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>        <span class="c1">; call our string printing with linefeed function</span>
    <span class="nf">call</span>    <span class="nv">quit</span>            <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf namespace.asm
$ ld -m elf_i386 namespace.o -o namespace
$ ./namespace
Jumping to finished label.
Inside subroutine number: <span class="m">1</span>
Jumping to finished label.
Inside subroutine number: <span class="m">2</span>
Jumping to finished label.
Inside subroutine <span class="s2">&#34;finished&#34;</span>.
</code></pre></div><hr>
<h2 id="lesson-18-fizzbuzz-游戏">Lesson 18 FizzBuzz 游戏</h2>
<p>FizzBuzz——老外在学校里教孩子除法的一组游戏。玩法：</p>
<ul>
<li>玩家轮流计算从<code>1</code>到<code>100</code>的整数，</li>
<li>遇到<code>3的倍数</code>就换成 Fizz，</li>
<li>遇到<code>5的倍数</code>就换成 Buzz，</li>
<li>遇到<code>3和5的公倍数</code>就换成 FizzBuzz。</li>
</ul>
<p>神奇的是这个儿童游戏已经成为计算机编程工作事实上的标准面试题之一，原因在于该题可以轻松的过滤掉连简单的逻辑门都构造不好的候选人。。。</p>
<p>解题办法不止一种，有些语言提供了非常简单而优雅的方案。然而大都是躲不过 if 语句的；可能还会含有 else，这取决于是否利用了某些数学性质，如：既能被 3 整除也能被 5 整除的数必然可以被 3 * 5 = 15 整除。</p>
<p>本篇的汇编实现，我们提供如下的方案：两个级联的 if 语句判断是否打印 Fizz 和/或 Buzz，以及一个 else 语句打印其他数字。每个输出都占一行，100个数字都处理完，程序退出。</p>
<h3 id="让我们的第拾捌个汇编程序来挑战一下大道至简">让我们的第拾捌个汇编程序来挑战一下——大道至简</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Fizzbuzz</span>
<span class="c1">; Compile with: nasm -f elf fizzbuzz.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 fizzbuzz.o -o fizzbuzz</span>
<span class="c1">; Run with: ./fizzbuzz</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">fizz</span>        <span class="nv">db</span>      <span class="s">&#39;Fizz&#39;</span><span class="p">,</span> <span class="mh">0h</span>     <span class="c1">; a message string</span>
<span class="nf">buzz</span>        <span class="nv">db</span>      <span class="s">&#39;Buzz&#39;</span><span class="p">,</span> <span class="mh">0h</span>     <span class="c1">; a message string</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; initialise our checkFizz boolean variable</span>
    <span class="nf">mov</span>     <span class="nb">edi</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; initialise our checkBuzz boolean variable</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; initialise our counter variable</span>
 
<span class="nl">nextNumber:</span>
    <span class="nf">inc</span>     <span class="nb">ecx</span>             <span class="c1">; increment our counter variable</span>
 
<span class="nf">.checkFizz</span>
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; clear the edx register - this will hold our remainder after division</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ecx</span>        <span class="c1">; move the value of our counter into eax for division</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">3</span>          <span class="c1">; move our number to divide by into ebx (in this case the value is 3)</span>
    <span class="nf">div</span>     <span class="nb">ebx</span>             <span class="c1">; divide eax by ebx</span>
    <span class="nf">mov</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edx</span>        <span class="c1">; move our remainder into edi (our checkFizz boolean variable)</span>
    <span class="nf">cmp</span>     <span class="nb">edi</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; compare if the remainder is zero (meaning the counter divides by 3)</span>
    <span class="nf">jne</span>     <span class="nv">.checkBuzz</span>      <span class="c1">; if the remainder is not equal to zero jump to local label checkBuzz</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">fizz</span>       <span class="c1">; else move the address of our fizz string into eax for printing</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our string printing function</span>
 
<span class="nl">.checkBuzz:</span>
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; clear the edx register - this will hold our remainder after division</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ecx</span>        <span class="c1">; move the value of our counter into eax for division</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">5</span>          <span class="c1">; move our number to divide by into ebx (in this case the value is 5)</span>
    <span class="nf">div</span>     <span class="nb">ebx</span>             <span class="c1">; divide eax by ebx</span>
    <span class="nf">mov</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">edx</span>        <span class="c1">; move our remainder into edi (our checkBuzz boolean variable)</span>
    <span class="nf">cmp</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; compare if the remainder is zero (meaning the counter divides by 5)</span>
    <span class="nf">jne</span>     <span class="nv">.checkInt</span>       <span class="c1">; if the remainder is not equal to zero jump to local label checkInt</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">buzz</span>       <span class="c1">; else move the address of our buzz string into eax for printing</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our string printing function</span>
 
<span class="nl">.checkInt:</span>
    <span class="nf">cmp</span>     <span class="nb">edi</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; edi contains the remainder after the division in checkFizz</span>
    <span class="nf">je</span>     <span class="nv">.continue</span>        <span class="c1">; if equal (counter divides by 3) skip printing the integer</span>
    <span class="nf">cmp</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mi">0</span>          <span class="c1">; esi contains the remainder after the division in checkBuzz</span>
    <span class="nf">je</span>     <span class="nv">.continue</span>        <span class="c1">; if equal (counter divides by 5) skip printing the integer</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ecx</span>        <span class="c1">; else move the value in ecx (our counter) into eax for printing</span>
    <span class="nf">call</span>    <span class="nv">iprint</span>          <span class="c1">; call our integer printing function</span>
 
<span class="nl">.continue:</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mh">0Ah</span>        <span class="c1">; move an ascii linefeed character into eax</span>
    <span class="nf">push</span>    <span class="nb">eax</span>             <span class="c1">; push the address of eax onto the stack for printing</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">esp</span>        <span class="c1">; get the stack pointer (address on the stack of our linefeed char)</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our string printing function to print a line feed</span>
    <span class="nf">pop</span>     <span class="nb">eax</span>             <span class="c1">; pop the stack so we don&#39;t waste resources</span>
    <span class="nf">cmp</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">100</span>        <span class="c1">; compare if our counter is equal to 100</span>
    <span class="nf">jne</span>     <span class="nv">nextNumber</span>      <span class="c1">; if not equal jump to the start of the loop</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>            <span class="c1">; else call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf fizzbuzz.asm
$ ld -m elf_i386 fizzbuzz.o -o fizzbuzz
$ ./fizzbuzz
<span class="m">1</span>
<span class="m">2</span>
Fizz
<span class="m">4</span>
Buzz
Fizz
<span class="m">7</span>
<span class="m">8</span>
Fizz
Buzz
<span class="m">11</span>
Fizz
<span class="m">13</span>
<span class="m">14</span>
FizzBuzz
<span class="m">16</span>
.
.
.
</code></pre></div><hr>
<h2 id="lesson-19-执行命令">Lesson 19 执行命令</h2>
<h3 id="再一次背景知识">再一次，背景知识</h3>
<p>通过指定的要运行的命令，调用<code>EXEC</code>一族的函数将启动一个新进程来替换当前的。本节，我们将使用<code>sys_execve</code>系统调用，启动 Linux 下的程序<code>/bin/echo</code>，来替换程序运行中的进程，我们让<code>/bin/echo</code>来输出&quot;Hello,World!&rdquo;</p>
<h3 id="命名约定">命名约定</h3>
<p>这一族的函数都以<code>exec</code>开头，后面跟着的字母含义如下：</p>
<ul>
<li>E，指向环境变量指针的数组，传给进程镜像</li>
<li>L，命令行参数分别传给函数</li>
<li>P，使用<code>PATH</code>环境变量查找路径参数中的命令名并执行</li>
<li>V，命令行参数作为指针数组传递给函数</li>
</ul>
<p>V 和 E 后缀的函数，意味着需要按如下格式传递参数：</p>
<ul>
<li>第一个参数是要被执行的命令的字符串，</li>
<li>后面跟着该命令的参数数组，</li>
<li>最后是新进程将用到的环境变量的数组。</li>
</ul>
<p>当我们调用一个简单的命令时，不将任何特殊的环境变量传递给新进程，而是传递 0h (NULL)。</p>
<p>命令的参数和环境变量都必须用指针的数组来传递。因此，在定义完字符串后，我们定义了一个包含变量名的null终结(0h结尾)的结构体(数组)。这样，就准备好了应传给<code>sys_execve</code>的所有东西。一旦调用成功，新进程将替换我们的进程，输出返回给了终端。</p>
<h3 id="第拾玖个汇编程序委重投艰">第拾玖个汇编程序——委重投艰</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Execute</span>
<span class="c1">; Compile with: nasm -f elf execute.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 execute.o -o execute</span>
<span class="c1">; Run with: ./execute</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">command</span>         <span class="nv">db</span>      <span class="s">&#39;/bin/echo&#39;</span><span class="p">,</span> <span class="mh">0h</span>     <span class="c1">; command to execute</span>
<span class="nf">arg1</span>            <span class="nv">db</span>      <span class="s">&#39;Hello World!&#39;</span><span class="p">,</span> <span class="mh">0h</span>
<span class="nf">arguments</span>       <span class="nv">dd</span>      <span class="nv">command</span>
                <span class="kd">dd</span>      <span class="nv">arg1</span>                <span class="c1">; arguments to pass to commandline (in this case just one)</span>
                <span class="kd">dd</span>      <span class="mh">0h</span>                  <span class="c1">; end the struct</span>
<span class="nf">environment</span>     <span class="nv">dd</span>      <span class="mh">0h</span>                  <span class="c1">; arguments to pass as environment variables (inthis case none) end the struct</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="nv">environment</span>    <span class="c1">; address of environment variables</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">arguments</span>      <span class="c1">; address of the arguments to pass to the commandline</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">command</span>        <span class="c1">; address of the file to execute</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">11</span>             <span class="c1">; invoke SYS_EXECVE (kernel opcode 11)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf execute.asm
$ ld -m elf_i386 execute.o -o execute
$ ./execute
Hello World!
</code></pre></div><blockquote>
<p>提示：不妨试试其他命令</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">command</span>         <span class="nv">db</span>      <span class="s">&#39;/bin/ls&#39;</span><span class="p">,</span> <span class="mh">0h</span>       <span class="c1">; command to execute</span>
<span class="nf">arg1</span>            <span class="nv">db</span>      <span class="s">&#39;-l&#39;</span><span class="p">,</span> <span class="mh">0h</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">command</span>         <span class="nv">db</span>      <span class="s">&#39;/bin/sleep&#39;</span><span class="p">,</span> <span class="mh">0h</span>    <span class="c1">; command to execute</span>
<span class="nf">arg1</span>            <span class="nv">db</span>      <span class="s">&#39;5&#39;</span><span class="p">,</span> <span class="mh">0h</span>
</code></pre></div><hr>
<h2 id="lesson-20-process-forking">Lesson 20 Process Forking</h2>
<h3 id="重入背景知识">重入，背景知识</h3>
<p>本节引入著名的<code>sys_fork</code>。这个调用不是替换，而是复制我们的进程。该调用不接受任何参数，只要在当前进程中调用，那么新进程就会被创建。新进程与原进程并发执行。</p>
<p>通过检测<code>EAX</code>中的值，来判断当前是处于父进程还是子进程中。父进程返回一个正整数；子进程中<code>EAX</code>为 0。以此可以对于父子进程进行分支逻辑。</p>
<p>基于以上事实，我们在父子进程中打印不同的消息。</p>
<blockquote>
<p>注意：每个进程需要各自安全退出</p>
</blockquote>
<h3 id="第贰拾个汇编程序如出一辙">第贰拾个汇编程序——如出一辙</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Fork</span>
<span class="c1">; Compile with: nasm -f elf fork.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 fork.o -o fork</span>
<span class="c1">; Run with: ./fork</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">childMsg</span>        <span class="nv">db</span>      <span class="s">&#39;This is the child process&#39;</span><span class="p">,</span> <span class="mh">0h</span>     <span class="c1">; a message string</span>
<span class="nf">parentMsg</span>       <span class="nv">db</span>      <span class="s">&#39;This is the parent process&#39;</span><span class="p">,</span> <span class="mh">0h</span>    <span class="c1">; a message string</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">2</span>              <span class="c1">; invoke SYS_FORK (kernel opcode 2)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">cmp</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">0</span>              <span class="c1">; if eax is zero we are in the child process</span>
    <span class="nf">jz</span>      <span class="nb">ch</span><span class="nv">ild</span>               <span class="c1">; jump if eax is zero to child label</span>
 
<span class="nl">parent:</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">parentMsg</span>      <span class="c1">; inside our parent process move parentMsg into eax</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>            <span class="c1">; call our string printing with linefeed function</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; quit the parent process</span>
 
<span class="nl">child:</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">ch</span><span class="nv">ildMsg</span>       <span class="c1">; inside our child process move childMsg into eax</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>            <span class="c1">; call our string printing with linefeed function</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; quit the child process</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf fork.asm
$ ld -m elf_i386 fork.o -o fork
$ ./fork
This is the parent process
This is the child process
</code></pre></div><hr>
<h2 id="lesson-21-输出时间">Lesson 21 输出时间</h2>
<p>在 NASM 中，生成一个 unix 时间戳只需简单的向内核调用<code>sys_time</code>，也即：调用表中的 OPCODE 13。不需要参数，返回的<a href="https://en.wikipedia.org/wiki/Unix_time">UNIX 纪元时间</a>保存在<code>EAX</code>寄存器中</p>
<h3 id="第贰拾壹个汇编程序只争朝夕">第贰拾壹个汇编程序——只争朝夕</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Time</span>
<span class="c1">; Compile with: nasm -f elf time.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 time.o -o time</span>
<span class="c1">; Run with: ./time</span>
<span class="cp"> 
</span><span class="cp">%include        &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">msg</span>        <span class="nv">db</span>      <span class="s">&#39;Seconds since Jan 01 1970: &#39;</span><span class="p">,</span> <span class="mh">0h</span>     <span class="c1">; a message string</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; move our message string into eax for printing</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>          <span class="c1">; call our string printing function</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">13</span>         <span class="c1">; invoke SYS_TIME (kernel opcode 13)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>             <span class="c1">; call the kernel</span>
 
    <span class="nf">call</span>    <span class="nv">iprintLF</span>        <span class="c1">; call our integer printing function with linefeed</span>
    <span class="nf">call</span>    <span class="nv">quit</span>            <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf time.asm
$ ld -m elf_i386 time.o -o <span class="nb">time</span>
$ ./time
Seconds since Jan <span class="m">01</span> 1970: <span class="m">1374995660</span>
</code></pre></div><hr>
<h2 id="lesson-22-文件操作create">Lesson 22 文件操作——Create</h2>
<h3 id="相关背景">相关背景</h3>
<p>文件操作在 Linux 系统中涉及到一小股系统调用，包括：创建、更新、删除。这些函数都必须作用于<a href="https://en.wikipedia.org/wiki/File_descriptor">文件描述符</a>——系统中用于标识文件的一个唯一的、非负整数。</p>
<p>首先登场的是用于创建文件的<code>sys_creat</code>。在后面的课程中，将在同一程序上不断扩展。最终，我们将有一个包含文件的创建、更新、打开、关闭和删除的完整功能的程序。</p>
<h3 id="我们的第贰拾贰个汇编程序本立道生">我们的第贰拾贰个汇编程序——本立道生</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Create</span>
<span class="c1">; Compile with: nasm -f elf create.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 create.o -o create</span>
<span class="c1">; Run with: ./create</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">filename</span> <span class="nv">db</span> <span class="s">&#39;readme.txt&#39;</span><span class="p">,</span>       <span class="c1">; the filename to create</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0777</span>           <span class="c1">; set all permissions to read, write, execute</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">filename</span>       <span class="c1">; filename we will create</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">8</span>              <span class="c1">; invoke SYS_CREAT (kernel opcode 8)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf create.asm
$ ld -m elf_i386 create.o -o create
$ ./create
</code></pre></div><blockquote>
<p>提示：“没有消息就是好消息”，文件 readme.txt 将出现在与程序相同的目录中</p>
</blockquote>
<hr>
<h2 id="lesson-23-文件操作write">Lesson 23 文件操作——Write</h2>
<p>基于上一节的程序，我们调用<code>sys_write</code>将内容写到新创建的文件。</p>
<p><code>sys_write</code>需要的 3 个参数由以下寄存器提供</p>
<ul>
<li>要写入的字节数载入<code>EDX</code></li>
<li>要写入内容的指针载入<code>ECX</code></li>
<li>文件描述符载入<code>EBX</code></li>
</ul>
<p>OPCODE 12 载入<code>EAX</code>，熟悉的套路，<code>INT 80h</code> 开调。留意，我们首先通过将文件名传给<code>sys_creat</code>，进而从<code>EAX</code>中得到文件描述符。</p>
<h3 id="我们的第贰拾叁个汇编程序握素怀铅">我们的第贰拾叁个汇编程序——握素怀铅</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Write</span>
<span class="c1">; Compile with: nasm -f elf write.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 write.o -o write</span>
<span class="c1">; Run with: ./write</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">filename</span> <span class="nv">db</span> <span class="s">&#39;readme.txt&#39;</span><span class="p">,</span> <span class="mh">0h</span>    <span class="c1">; the filename to create</span>
<span class="nf">contents</span> <span class="nv">db</span> <span class="s">&#39;Hello world!&#39;</span><span class="p">,</span> <span class="mh">0h</span>  <span class="c1">; the contents to write</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0777</span>           <span class="c1">; code continues from lesson 22</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">filename</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">8</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">12</span>             <span class="c1">; number of bytes to write - one for each letter of our contents string</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">contents</span>       <span class="c1">; move the memory address of our contents string into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; move the file descriptor of the file we created into ebx</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>              <span class="c1">; invoke SYS_WRITE (kernel opcode 4)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf write.asm
$ ld -m elf_i386 write.o -o write
$ ./write
</code></pre></div><blockquote>
<p>提示：执行完打开 readme.txt 看看吧，该有 Hello, World! 才对</p>
</blockquote>
<hr>
<h2 id="lesson-24-文件操作open">Lesson 24 文件操作——Open</h2>
<p>继续扩展前面的程序，这次轮到<code>sys_open</code>登场。这个调用用来获取文件描述符，而文件描述符则作为后面其他文件相关函数的参数。</p>
<p><code>sys_open</code>需要的两个参数：</p>
<ul>
<li>访问模式(见下表)载入<code>ECX</code></li>
<li><code>EBX</code>则存着文件名</li>
</ul>
<p>系统调用的方法我们已经很熟悉了：OPCODE 5 载入<code>EAX</code>，<code>INT 80h</code> 开调。</p>
<p><code>sys_open</code>也可以额外接受 0 个或多个表示文件创建和文件状态的标志，通过<code>EDX</code>读取。详情参见：<a href="https://man7.org/linux/man-pages/man2/open.2.html">open(2) —— Linux manual page</a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_RDONLY</td>
<td>只读打开</td>
<td>0</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>只写打开</td>
<td>1</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>读写打开</td>
<td>2</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：调用<code>sys_open</code>后，我们从<code>EAX</code>中获得文件描述符，然后使用整数打印函数将这个在 Linux 中唯一的，非负整数的值打印出来</p>
</blockquote>
<h3 id="写下我们的第贰拾肆个汇编程序招之即来">写下我们的第贰拾肆个汇编程序——招之即来</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Open</span>
<span class="c1">; Compile with: nasm -f elf open.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 open.o -o open</span>
<span class="c1">; Run with: ./open</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">filename</span> <span class="nv">db</span> <span class="s">&#39;readme.txt&#39;</span><span class="p">,</span> <span class="mh">0h</span>    <span class="c1">; the filename to create</span>
<span class="nf">contents</span> <span class="nv">db</span> <span class="s">&#39;Hello world!&#39;</span><span class="p">,</span> <span class="mh">0h</span>  <span class="c1">; the contents to write</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0777</span>           <span class="c1">; Create file from lesson 22</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">filename</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">8</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">12</span>             <span class="c1">; Write contents to file from lesson 23</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">contents</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>              <span class="c1">; flag for readonly access mode (O_RDONLY)</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">filename</span>       <span class="c1">; filename we created above</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">5</span>              <span class="c1">; invoke SYS_OPEN (kernel opcode 5)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">call</span>    <span class="nv">iprintLF</span>            <span class="c1">; call our integer printing function</span>
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf open.asm
$ ld -m elf_i386 open.o -o open
$ ./open
<span class="m">4</span>
</code></pre></div><hr>
<h2 id="lesson-25-文件操作read">Lesson 25 文件操作——Read</h2>
<p>介绍了创建、写入、打开，也该读取了。本节我们使用<code>sys_read</code>读取新建且打开的文件，内容存到一个变量中。</p>
<p><code>sys_read</code>的 3 个参数如下：</p>
<ul>
<li>要读取的字节数载入<code>EDX</code></li>
<li>保存内容的变量地址载入<code>ECX</code></li>
<li><code>EBX</code>中放文件描述符(通过上一节的<code>sys_open</code>获取)</li>
</ul>
<p>OPCODE 3 载入<code>EAX</code>，<code>INT 80h</code> 开调。</p>
<h3 id="第贰拾伍个汇编程序一览无遗">第贰拾伍个汇编程序——一览无遗</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Read</span>
<span class="c1">; Compile with: nasm -f elf read.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 read.o -o read</span>
<span class="c1">; Run with: ./read</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">filename</span> <span class="nv">db</span> <span class="s">&#39;readme.txt&#39;</span><span class="p">,</span> <span class="mh">0h</span>    <span class="c1">; the filename to create</span>
<span class="nf">contents</span> <span class="nv">db</span> <span class="s">&#39;Hello world!&#39;</span><span class="p">,</span> <span class="mh">0h</span>  <span class="c1">; the contents to write</span>
 
<span class="k">SECTION</span> <span class="nv">.bss</span>
<span class="nf">fileContents</span> <span class="nv">resb</span> <span class="mi">255</span><span class="p">,</span>          <span class="c1">; variable to store file contents</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0777</span>           <span class="c1">; Create file from lesson 22</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">filename</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">8</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">12</span>             <span class="c1">; Write contents to file from lesson 23</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">contents</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>              <span class="c1">; Open file from lesson 24</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">filename</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">5</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">12</span>             <span class="c1">; number of bytes to read - one for each letter of the file contents</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">fileContents</span>   <span class="c1">; move the memory address of our file contents variable into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; move the opened file descriptor into EBX</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">3</span>              <span class="c1">; invoke SYS_READ (kernel opcode 3)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">fileContents</span>   <span class="c1">; move the memory address of our file contents variable into eax for printing</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>            <span class="c1">; call our string printing function</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf read.asm
$ ld -m elf_i386 read.o -o <span class="nb">read</span>
$ ./read
Hello world!
</code></pre></div><hr>
<h2 id="lesson-26-文件操作close">Lesson 26 文件操作——Close</h2>
<p>抱歉这么重要的操作现在才引入，正确的关闭文件等资源无论在那种语言编写的程序中都是不可或缺的步骤，本节引入<code>sys_close</code>。</p>
<p><code>sys_close</code>只需要一个参数：</p>
<ul>
<li>藉由<code>EBX</code>将文件描述符传给内核</li>
</ul>
<p>扩展上一节的程序——在获取到文件描述符后，我们将其放入EBX。</p>
<p>OPCODE 6 载入<code>EAX</code>，<code>INT 80h</code> 开调。</p>
<h3 id="我们的负责任的第贰拾陆个汇编程序止戈散马">我们的负责任的第贰拾陆个汇编程序——止戈散马</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Close</span>
<span class="c1">; Compile with: nasm -f elf close.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 close.o -o close</span>
<span class="c1">; Run with: ./close</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">filename</span> <span class="nv">db</span> <span class="s">&#39;readme.txt&#39;</span><span class="p">,</span> <span class="mh">0h</span>    <span class="c1">; the filename to create</span>
<span class="nf">contents</span> <span class="nv">db</span> <span class="s">&#39;Hello world!&#39;</span><span class="p">,</span> <span class="mh">0h</span>  <span class="c1">; the contents to write</span>
 
<span class="k">SECTION</span> <span class="nv">.bss</span>
<span class="nf">fileContents</span> <span class="nv">resb</span> <span class="mi">255</span><span class="p">,</span>          <span class="c1">; variable to store file contents</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0777</span>           <span class="c1">; Create file from lesson 22</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">filename</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">8</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">12</span>             <span class="c1">; Write contents to file from lesson 23</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">contents</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>              <span class="c1">; Open file from lesson 24</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">filename</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">5</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">12</span>             <span class="c1">; Read file from lesson 25</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">fileContents</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">3</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">fileContents</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>
 
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>            <span class="c1">; not needed but used to demonstrate that SYS_CLOSE takes a file descriptor from EBX</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">6</span>              <span class="c1">; invoke SYS_CLOSE (kernel opcode 6)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf close.asm
$ ld -m elf_i386 close.o -o close
$ ./close
Hello world!
</code></pre></div><blockquote>
<p>提示：我们正确的关闭了文件，将文件描述符等一干资源还回了操作系统</p>
</blockquote>
<hr>
<h2 id="lesson-27-文件操作seek">Lesson 27 文件操作——Seek</h2>
<p>之前的课程都是对文件整存整取操作，但实际应用中的更多是对文件的局部修改。本节引入<code>sys_lseek</code>，演示在文件的结尾追加内容。</p>
<p>通过<code>sys_lseek</code>你可以在文件中移动一个叫游标的玩意儿，同时用字节为单位的偏移量来精确定位。下面的例子演示了移动到文件结尾，并用 0 字节偏移量(这样保证我们在末尾写入而不是超出)来定位写入的位置。在<code>ECX</code>和<code>EDX</code>中尝试不同的值在文件的不同位置写入。</p>
<p><code>sys_lseek</code>的3个参数这样传递：</p>
<ul>
<li><code>EDX</code>保存从哪开始，可选的值如下表</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>SEEK_SET</td>
<td>文件的开头</td>
<td>0</td>
</tr>
<tr>
<td>SEEK_CUR</td>
<td>当前位置偏移量</td>
<td>1</td>
</tr>
<tr>
<td>SEEK_END</td>
<td>文件的结尾</td>
<td>2</td>
</tr>
</tbody>
</table>
<ul>
<li>偏移量存进<code>ECX</code></li>
<li>最后自然就是文件描述符了，由<code>EBX</code>存储</li>
</ul>
<p>OPCODE 19 载入<code>EAX</code>，<code>INT 80h</code> 开调。定位到期望的位置后，我们调用了<code>sys_write</code>更新文件的内容。</p>
<blockquote>
<p>注意：本程序没有创建文件的过程，是在已经存在的 readme.txt 文件上操作的。程序运行后该文件的内容将被更新</p>
</blockquote>
<h3 id="有请我们的第贰拾柒个汇编程序上下求索">有请我们的第贰拾柒个汇编程序——上下求索</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Seek</span>
<span class="c1">; Compile with: nasm -f elf seek.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 seek.o -o seek</span>
<span class="c1">; Run with: ./seek</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">filename</span> <span class="nv">db</span> <span class="s">&#39;readme.txt&#39;</span><span class="p">,</span> <span class="mh">0h</span>    <span class="c1">; the filename to create</span>
<span class="nf">contents</span>  <span class="nv">db</span> <span class="s">&#39;-updated-&#39;</span><span class="p">,</span> <span class="mh">0h</span>     <span class="c1">; the contents to write at the start of the file</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">1</span>              <span class="c1">; flag for writeonly access mode (O_WRONLY)</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">filename</span>       <span class="c1">; filename of the file to open</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">5</span>              <span class="c1">; invoke SYS_OPEN (kernel opcode 5)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">2</span>              <span class="c1">; whence argument (SEEK_END)</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>              <span class="c1">; move the cursor 0 bytes</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; move the opened file descriptor into EBX</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">19</span>             <span class="c1">; invoke SYS_LSEEK (kernel opcode 19)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">9</span>              <span class="c1">; number of bytes to write - one for each letter of our contents string</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">contents</span>       <span class="c1">; move the memory address of our contents string into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>            <span class="c1">; move the opened file descriptor into EBX (not required as EBX already has the FD)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>              <span class="c1">; invoke SYS_WRITE (kernel opcode 4)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf seek.asm
$ ld -m elf_i386 seek.o -o seek
$ ./seek
</code></pre></div><hr>
<h2 id="lesson-28-文件操作delete">Lesson 28 文件操作——Delete</h2>
<p>文件删除在 Linux 中由系统调用<code>sys_unlink</code>(差点写成 unlike)提供。</p>
<p><code>sys_unlink</code>只需要一个参数：</p>
<ul>
<li>把文件名放入<code>EBX</code></li>
</ul>
<p>OPCODE 10 载入<code>EAX</code>，<code>INT 80h</code> 开调。</p>
<blockquote>
<p>注意：readme.txt 是已经存在的文件。程序运行完成，该文件将被删除</p>
</blockquote>
<h3 id="我们的第贰拾捌个汇编程序一扫而尽">我们的第贰拾捌个汇编程序——一扫而尽</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Unlink</span>
<span class="c1">; Compile with: nasm -f elf unlink.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 unlink.o -o unlink</span>
<span class="c1">; Run with: ./unlink</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="nf">filename</span> <span class="nv">db</span> <span class="s">&#39;readme.txt&#39;</span><span class="p">,</span> <span class="mh">0h</span>    <span class="c1">; the filename to delete</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nv">filename</span>       <span class="c1">; filename we will delete</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">10</span>             <span class="c1">; invoke SYS_UNLINK (kernel opcode 10)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf unlink.asm
$ ld -m elf_i386 unlink.o -o unlink
$ ./unlink
</code></pre></div><hr>
<h2 id="lesson-29-套接字create">Lesson 29 套接字——Create</h2>
<h3 id="背景知识走起">背景知识，走起</h3>
<p>Linux 中的套接字编程，藉由<code>sys_socketcall</code>内核函数提供。与文件操作的一族函数不同，他一人就封装了套接字相关的全部操作，全都以子例程的形式存在其中。我们通过在<code>EBX</code>中传递给他不同的值，来区分诸如：创建、监听、发送、接受、关闭等操作。这里有<a href="https://gist.github.com/DGivney/7196bd7a9f21a12c9397bdcf9ae040d2">详细注释的完整程序</a>以供参考。</p>
<p>发起系统调用前，需要初始化一些寄存器，用以存储后面的重要数据。接着调用<code>sys_socketcall</code>的第一个子例程<code>socket</code>来创建套接字。之后的课程中，将在此程序基础上按需扩充。最终，我们将拥有一个包含：创建、绑定、监听、接受、读取、写入和关闭的完整套接字程序。</p>
<p><code>sys_socketcall</code>的子例程<code>socket</code>接收两个参数：</p>
<ul>
<li>参数数组的指针由<code>ECX</code>保存</li>
<li>整数 1 由<code>EBX</code>保存</li>
</ul>
<p>OPCODE 102 载入<code>EAX</code>，<code>INT 80h</code> 开调。</p>
<p>在 Linux 中<strong>一切皆文件</strong>，成功创建后的套接字将作为文件描述符(FD)由<code>EAX</code>返回给用户程序。这个 FD 将用来实施其他的套接字函数。</p>
<blockquote>
<p>提示：一个寄存器对自身进行 XOR 异或是初始化(清零)的好办法，这可以确保其中不包含意外的值，从而避免程序崩溃。</p>
</blockquote>
<h3 id="套接字我们的第贰拾玖个汇编程序来了只如初见">套接字，我们的第贰拾玖个汇编程序来了——只如初见</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Socket</span>
<span class="c1">; Compile with: nasm -f elf socket.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket</span>
<span class="c1">; Run with: ./socket</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">xor</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; init eax 0</span>
    <span class="nf">xor</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>            <span class="c1">; init ebx 0</span>
    <span class="nf">xor</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>            <span class="c1">; init edi 0</span>
    <span class="nf">xor</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>            <span class="c1">; init esi 0</span>
 
<span class="nl">_socket:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">6</span>              <span class="c1">; push 6 onto the stack (IPPROTO_TCP)</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>              <span class="c1">; push 1 onto the stack (SOCK_STREAM)</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">2</span>              <span class="c1">; push 2 onto the stack (PF_INET)</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">; move address of arguments into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>              <span class="c1">; invoke subroutine SOCKET (1)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>            <span class="c1">; invoke SYS_SOCKETCALL (kernel opcode 102)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">call</span>    <span class="nv">iprintLF</span>            <span class="c1">; call our integer printing function (print the file descriptor in EAX or -1 on error)</span>
 
<span class="nl">_exit:</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf socket.asm
$ ld -m elf_i386 socket.o -o socket
$ ./socket
<span class="m">3</span>
</code></pre></div><hr>
<h2 id="lesson-30-套接字bind">Lesson 30 套接字——Bind</h2>
<p>上一节完成了套接字的创建，现在我们为这个套接字关联一个本地 IP 和端口以便其他程序与其建立连接。这个任务由<code>sys_cocketcall</code>的第二个子例程<code>bind</code>完成。</p>
<p>这里引入新的寄存器<code>EDI</code>来存储套接字的文件描述符(FD)。<code>EDI</code>——目标索引寄存器，原做拷贝过程中存储目标文件的位置之用。</p>
<p><code>sys_socketcall</code>的子例程<code>bind</code>也接收两个参数：</p>
<ul>
<li>参数数组的指针由<code>ECX</code>保存</li>
<li>整数 2 由<code>EBX</code>保存</li>
</ul>
<p>OPCODE 102 载入<code>EAX</code>，<code>INT 80h</code> 开调。</p>
<h3 id="第叁拾个汇编程序一朝比翼">第叁拾个汇编程序——一朝比翼</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Socket</span>
<span class="c1">; Compile with: nasm -f elf socket.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket</span>
<span class="c1">; Run with: ./socket</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">xor</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; initialize some registers</span>
    <span class="nf">xor</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">xor</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>
    <span class="nf">xor</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>
 
<span class="nl">_socket:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">6</span>              <span class="c1">; create socket from lesson 29</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_bind:</span>
 
    <span class="nf">mov</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; move return value of SYS_SOCKETCALL into edi (file descriptor for new socket, or -1 on error)</span>
    <span class="nf">push</span>    <span class="kt">dword</span> <span class="mh">0x00000000</span>    <span class="c1">; push 0 dec onto the stack IP ADDRESS (0.0.0.0)</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mh">0x2923</span>         <span class="c1">; push 9001 dec onto stack PORT (reverse byte order)</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mi">2</span>              <span class="c1">; push 2 dec onto stack AF_INET</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">; move address of stack pointer into ecx</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">16</span>             <span class="c1">; push 16 dec onto stack (arguments length)</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>                 <span class="c1">; push the address of arguments onto stack</span>
    <span class="nf">push</span>    <span class="nb">edi</span>                 <span class="c1">; push the file descriptor onto stack</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">; move address of arguments into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">2</span>              <span class="c1">; invoke subroutine BIND (2)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>            <span class="c1">; invoke SYS_SOCKETCALL (kernel opcode 102)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
<span class="nl">_exit:</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf socket.asm
$ ld -m elf_i386 socket.o -o socket
$ ./socket
</code></pre></div><hr>
<h2 id="lesson-31-套接字listen">Lesson 31 套接字——Listen</h2>
<p>上一节完成了套接字的绑定。下面由<code>sys_socketcall</code>的<code>listen</code>子例程告诉我们的套接字监听<code>TCP</code>的入站请求。这是在套接字上对与我们相互连接的程序进行读写的前提。</p>
<p><code>sys_socketcall</code>的子例程<code>listen</code>也接收两个参数：</p>
<ul>
<li>参数数组的指针由<code>ECX</code>保存</li>
<li>整数 4 由<code>EBX</code>保存</li>
</ul>
<p>OPCODE 102 载入<code>EAX</code>，<code>INT 80h</code> 开调。调用成功后，套接字即开始监听入站请求。</p>
<h3 id="我们的第叁拾壹个汇编程序伫候佳音">我们的第叁拾壹个汇编程序——伫候佳音</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Socket</span>
<span class="c1">; Compile with: nasm -f elf socket.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket</span>
<span class="c1">; Run with: ./socket</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">xor</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; initialize some registers</span>
    <span class="nf">xor</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">xor</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>
    <span class="nf">xor</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>
 
<span class="nl">_socket:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">6</span>              <span class="c1">; create socket from lesson 29</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_bind:</span>
 
    <span class="nf">mov</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; bind socket from lesson 30</span>
    <span class="nf">push</span>    <span class="kt">dword</span> <span class="mh">0x00000000</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mh">0x2923</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">16</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_listen:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>              <span class="c1">; move 1 onto stack (max queue length argument)</span>
    <span class="nf">push</span>    <span class="nb">edi</span>                 <span class="c1">; push the file descriptor onto stack</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">; move address of arguments into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">4</span>              <span class="c1">; invoke subroutine LISTEN (4)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>            <span class="c1">; invoke SYS_SOCKETCALL (kernel opcode 102)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
<span class="nl">_exit:</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf socket.asm
$ ld -m elf_i386 socket.o -o socket
$ ./socket
</code></pre></div><hr>
<h2 id="lesson-32-套接字accept">Lesson 32 套接字——Accept</h2>
<p>前面的课程都是套接字的准备工作。入站请求到达后，还必须有接受逻辑，这由<code>sys_socketcall</code>的<code>accept</code>子例程实现。进入 ACCEPT 状态的套接字可以在远程连接上进行读写。</p>
<p><code>sys_socketcall</code>的子例程<code>accept</code>也接收两个参数：</p>
<ul>
<li>参数数组的指针由<code>ECX</code>保存</li>
<li>整数 5 由<code>EBX</code>保存</li>
</ul>
<p>OPCODE 102 载入<code>EAX</code>，<code>INT 80h</code> 开调。<code>accept</code>子例程将创建另一个文件描述符(FD)，用以标识入站连接。我们后面的课程将使用这个 FD 来进行实际的读写操作。</p>
<blockquote>
<p>提示：运行本程序后，开启另一个终端窗口，键入<code>sudo netstat -plnt</code>查看 9001 端口是否在监听之中</p>
</blockquote>
<h3 id="第叁拾贰个汇编程序宾至如归">第叁拾贰个汇编程序——宾至如归</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Socket</span>
<span class="c1">; Compile with: nasm -f elf socket.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket</span>
<span class="c1">; Run with: ./socket</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">xor</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; initialize some registers</span>
    <span class="nf">xor</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">xor</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>
    <span class="nf">xor</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>
 
<span class="nl">_socket:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">6</span>              <span class="c1">; create socket from lesson 29</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_bind:</span>
 
    <span class="nf">mov</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; bind socket from lesson 30</span>
    <span class="nf">push</span>    <span class="kt">dword</span> <span class="mh">0x00000000</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mh">0x2923</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">16</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_listen:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>              <span class="c1">; listen socket from lesson 31</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_accept:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">0</span>              <span class="c1">; push 0 dec onto stack (address length argument)</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">0</span>              <span class="c1">; push 0 dec onto stack (address argument)</span>
    <span class="nf">push</span>    <span class="nb">edi</span>                 <span class="c1">; push the file descriptor onto stack</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">; move address of arguments into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">5</span>              <span class="c1">; invoke subroutine ACCEPT (5)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>            <span class="c1">; invoke SYS_SOCKETCALL (kernel opcode 102)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
<span class="nl">_exit:</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf socket.asm
$ ld -m elf_i386 socket.o -o socket
$ ./socket
</code></pre></div><hr>
<h2 id="lesson-33-套接字read">Lesson 33 套接字——Read</h2>
<p>套接字也建立了，地址和端口也绑定了，监听中的套接字接受了入站连接，现在该让我们看看远端发来的请求里有什么了吧……</p>
<p>当入站连接被套接字接受后，一个新的文件描述符(FD)通过<code>EAX</code>返回给用户程序。本节将使用这个 FD 从连接中读取请求头。</p>
<p>先将获取到的 FD 存入<code>ESI</code>寄存器——原址索引寄存器，原做拷贝过程中存储来源文件的位置之用。</p>
<p><code>sys_read</code>是我们的老朋友了，就靠它从套接字连接中读取数据。正如前面的课程中所做的，我们用一个变量来保存从 FD 中读取的内容。本例的套接字使用传说中的<code>HTTP</code>协议进行通讯。分析<code>HTTP</code>请求头部，进而确认入站消息的长度、客户端接收的响应格式等内容超出了本教程的范畴。为了简化，只读取前 255 个字节并打印到标准输出。</p>
<p>一旦入站连接被接受，Web 服务器通常会生成一个子进程来接管读/写通信。父进程得以抽身继续监听和接收新的请求。我们就用前不久学过的<code>sys_fock</code>系统调用和<code>JMP</code>汇编指令来实现这一模式。</p>
<p>使用 curl 工具作为客户端来帮我们生成有效的请求头，并连接到套接字。当然你也可以使用浏览器。</p>
<blockquote>
<p>注意：我们在 .bss 段预留 255 字节空间用以存储从 FD 中读取到的内容。.bss 段的信息可以回顾 <a href="#lesson-9-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%87%BA">Lesson 9</a></p>
</blockquote>
<blockquote>
<p>提示：程序运行起来后，在另一个终端窗口的命令行输入<code>curl http://localhost:9001</code>来查看程序读取到的请求头</p>
</blockquote>
<h3 id="我们的第叁拾叁个汇编程序目营心匠">我们的第叁拾叁个汇编程序——目营心匠</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Socket</span>
<span class="c1">; Compile with: nasm -f elf socket.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket</span>
<span class="c1">; Run with: ./socket</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.bss</span>
<span class="nf">buffer</span> <span class="nv">resb</span> <span class="mi">255</span><span class="p">,</span>                <span class="c1">; variable to store request headers</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">xor</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; initialize some registers</span>
    <span class="nf">xor</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">xor</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>
    <span class="nf">xor</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>
 
<span class="nl">_socket:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">6</span>              <span class="c1">; create socket from lesson 29</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_bind:</span>
 
    <span class="nf">mov</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; bind socket from lesson 30</span>
    <span class="nf">push</span>    <span class="kt">dword</span> <span class="mh">0x00000000</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mh">0x2923</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">16</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_listen:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>              <span class="c1">; listen socket from lesson 31</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_accept:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">0</span>              <span class="c1">; accept socket from lesson 32</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">0</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">5</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_fork:</span>
 
    <span class="nf">mov</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; move return value of SYS_SOCKETCALL into esi (file descriptor for accepted socket, or -1 on error)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">2</span>              <span class="c1">; invoke SYS_FORK (kernel opcode 2)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">cmp</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">0</span>              <span class="c1">; if return value of SYS_FORK in eax is zero we are in the child process</span>
    <span class="nf">jz</span>      <span class="nv">_read</span>               <span class="c1">; jmp in child process to _read</span>
 
    <span class="nf">jmp</span>     <span class="nv">_accept</span>             <span class="c1">; jmp in parent process to _accept</span>
 
<span class="nl">_read:</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">255</span>            <span class="c1">; number of bytes to read (we will only read the first 255 bytes for simplicity)</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">buffer</span>         <span class="c1">; move the memory address of our buffer variable into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esi</span>            <span class="c1">; move esi into ebx (accepted socket file descriptor)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">3</span>              <span class="c1">; invoke SYS_READ (kernel opcode 3)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">buffer</span>         <span class="c1">; move the memory address of our buffer variable into eax for printing</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>            <span class="c1">; call our string printing function</span>
 
<span class="nl">_exit:</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf socket.asm
$ ld -m elf_i386 socket.o -o socket
$ ./socket
GET / HTTP/1.1
Host: localhost:9001
User-Agent: curl/x.xx.x
Accept: */*
</code></pre></div><hr>
<h2 id="lesson-34-套接字write">Lesson 34 套接字——Write</h2>
<p>上一节介绍完在套接字上读取，本节说说向套接字写入。</p>
<p>得益于 Linux 中的<strong>一切皆文件</strong>，我们可以使用已经掌握的<code>sys_write</code>向套接字连接写入数据。程序依然使用<code>HTTP</code>协议。这次作为服务端的我们的程序没人帮忙了，必须要自己构造规定的响应头给客户端程序。格式遵循 <a href="https://tools.ietf.org/html/rfc2616?spm=5176.doc32013.2.3.Aimyd7#section-4.2">RFC 标准</a>。</p>
<blockquote>
<p>注意：对于已知的值，使用 .data 段来存储。回顾 <a href="#lesson-1-hello-world">Lesson 1</a> 关于 .data 段的信息</p>
</blockquote>
<blockquote>
<p>提示：运行程序，在另一个终端窗口中输入命令<code>curl http://localhost:9001</code>查看响应；或者使用浏览器访问上述地址</p>
</blockquote>
<h3 id="神功将成的第叁拾肆个汇编程序其应若响">神功将成的第叁拾肆个汇编程序——其应若响</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Socket</span>
<span class="c1">; Compile with: nasm -f elf socket.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket</span>
<span class="c1">; Run with: ./socket</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="c1">; our response string</span>
<span class="nf">response</span> <span class="nv">db</span> <span class="s">&#39;HTTP/1.1 200 OK&#39;</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="s">&#39;Content-Type: text/html&#39;</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="s">&#39;Content-Length: 14&#39;</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="s">&#39;Hello World!&#39;</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="mh">0h</span>
 
<span class="k">SECTION</span> <span class="nv">.bss</span>
<span class="nf">buffer</span> <span class="nv">resb</span> <span class="mi">255</span><span class="p">,</span>                <span class="c1">; variable to store request headers</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">xor</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; initialize some registers</span>
    <span class="nf">xor</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">xor</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>
    <span class="nf">xor</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>
 
<span class="nl">_socket:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">6</span>              <span class="c1">; create socket from lesson 29</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_bind:</span>
 
    <span class="nf">mov</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; bind socket from lesson 30</span>
    <span class="nf">push</span>    <span class="kt">dword</span> <span class="mh">0x00000000</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mh">0x2923</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">16</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_listen:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>              <span class="c1">; listen socket from lesson 31</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_accept:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">0</span>              <span class="c1">; accept socket from lesson 32</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">0</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">5</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_fork:</span>
 
    <span class="nf">mov</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; fork socket from lesson 33</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">cmp</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">jz</span>      <span class="nv">_read</span>
 
    <span class="nf">jmp</span>     <span class="nv">_accept</span>
 
<span class="nl">_read:</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">255</span>            <span class="c1">; read socket from lesson 33</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">buffer</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esi</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">3</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">buffer</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>
 
<span class="nl">_write:</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">78</span>             <span class="c1">; move 78 dec into edx (length in bytes to write)</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">response</span>       <span class="c1">; move address of our response variable into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esi</span>            <span class="c1">; move file descriptor into ebx (accepted socket id)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>              <span class="c1">; invoke SYS_WRITE (kernel opcode 4)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
<span class="nl">_exit:</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf socket.asm
$ ld -m elf_i386 socket.o -o socket
$ ./socket
</code></pre></div><p>再开一个终端窗口</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl http://localhost:9001
Hello World!
</code></pre></div><hr>
<h2 id="lesson-35-套接字close">Lesson 35 套接字——Close</h2>
<p>又一次，来到释放资源的关键步骤！正确的关闭链接和关闭文件一样重要。在程序将响应返回给客户端后，我们要关闭子进程中的活动套接字。归还的资源用来接收新到来的链接。</p>
<p><code>sys_close</code>不多说，直接秀码——</p>
<blockquote>
<p>提示：程序启动后，同样新开一个终端窗口查看响应</p>
</blockquote>
<h3 id="我们的第叁拾伍个汇编程序功成身退">我们的第叁拾伍个汇编程序——功成身退</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Socket</span>
<span class="c1">; Compile with: nasm -f elf socket.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket</span>
<span class="c1">; Run with: ./socket</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="c1">; our response string</span>
<span class="nf">response</span> <span class="nv">db</span> <span class="s">&#39;HTTP/1.1 200 OK&#39;</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="s">&#39;Content-Type: text/html&#39;</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="s">&#39;Content-Length: 14&#39;</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="s">&#39;Hello World!&#39;</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="mh">0h</span>
 
<span class="k">SECTION</span> <span class="nv">.bss</span>
<span class="nf">buffer</span> <span class="nv">resb</span> <span class="mi">255</span><span class="p">,</span>                <span class="c1">; variable to store request headers</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">xor</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; initialize some registers</span>
    <span class="nf">xor</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">xor</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>
    <span class="nf">xor</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>
 
<span class="nl">_socket:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">6</span>              <span class="c1">; create socket from lesson 29</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_bind:</span>
 
    <span class="nf">mov</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; bind socket from lesson 30</span>
    <span class="nf">push</span>    <span class="kt">dword</span> <span class="mh">0x00000000</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mh">0x2923</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">16</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_listen:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>              <span class="c1">; listen socket from lesson 31</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_accept:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">0</span>              <span class="c1">; accept socket from lesson 32</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">0</span>
    <span class="nf">push</span>    <span class="nb">edi</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">5</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_fork:</span>
 
    <span class="nf">mov</span>     <span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; fork socket from lesson 33</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">cmp</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">jz</span>      <span class="nv">_read</span>
 
    <span class="nf">jmp</span>     <span class="nv">_accept</span>
 
<span class="nl">_read:</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">255</span>            <span class="c1">; read socket from lesson 33</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">buffer</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esi</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">3</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">buffer</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rintLF</span>
 
<span class="nl">_write:</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">78</span>             <span class="c1">; write socket from lesson 34</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">response</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esi</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mh">80h</span>
 
<span class="nl">_close:</span>
 
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esi</span>            <span class="c1">; move esi into ebx (accepted socket file descriptor)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">6</span>              <span class="c1">; invoke SYS_CLOSE (kernel opcode 6)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
<span class="nl">_exit:</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf socket.asm
$ ld -m elf_i386 socket.o -o socket
$ ./socket
</code></pre></div><p>同样，再另一个终端窗口中</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl http://localhost:9001
Hello World!
</code></pre></div><hr>
<h2 id="lesson-36-套接字下载网页">Lesson 36 套接字——下载网页</h2>
<p>前面的课程中，我们见识了<code>sys_socketcall</code>的众多子例程是如何创建、管理 Linux 套接字并在其中传输数据的，主要集中在服务端程序。接下来，从客户端的角度，使用<code>connect</code>子例程来演示——从远端下载网页。</p>
<p>步骤如下：</p>
<ul>
<li>首先调用<code>sys_socketcall</code>的<code>socket</code>子例程创建套接字，用来将请求发送到远端</li>
<li>然后调用<code>sys_socketcall</code>的<code>connect</code>子例程将刚创建的套接字连到远程 Web 服务器</li>
<li>之后调用<code>sys_write</code>发送<code>HTTP</code>格式的请求</li>
<li>接着调用<code>sys_read</code>接收来自 Web 服务器的<code>HTTP</code>格式响应</li>
</ul>
<p>服务器返回的响应内容，自然由我们的字符串打印函数代劳输出到终端上。</p>
<p><strong>简单介绍下 HTTP 请求</strong></p>
<p>HTTP 规范涉及多个版本的标准：<a href="https://tools.ietf.org/html/rfc1945">1.0 in RFC1945</a>，<a href="https://tools.ietf.org/html/rfc2068">1.1 in RFC2068</a> 以及 <a href="https://tools.ietf.org/html/rfc7540">2.0 in RFC7540</a>。1.1 版本时至今日依然是主流。</p>
<p>一个 HTTP 请求包含 3 个部分：</p>
<ol>
<li>一个包含<code>请求方法</code>、<code>请求 URL</code>和<code>协议版本</code>的行</li>
<li>可选的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">请求头</a>部分</li>
<li>一个空行，用以告知服务器请求方以完成请求并等待服务器响应</li>
</ol>
<p>一个典型的到根文档的 HTTP 请求一般长这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">GET / HTTP/1.1                  <span class="p">;</span> A line containing the request method, url and version
Host: asmtutor.com              <span class="p">;</span> A section of request headers
                                <span class="p">;</span> A required empty line
</code></pre></div><p>本节的程序与上一节的程序拥有相似的开头部分，但作为客户端的我们，不需要调用<code>bind</code>，取而代之的是调用<code>connect</code>，连接到指定 IP 地址和端口的远程 Web 服务器。然后使用<code>sys_write</code>和<code>sys_read</code>在两个套接字之间通过<code>HTTP请求</code>和<code>HTTP响应</code>来传输数据。</p>
<p><code>sys_socketcall</code>的子例程<code>connect</code>接收两个参数：</p>
<ul>
<li>参数数组的指针由<code>ECX</code>保存</li>
<li>整数 3 由<code>EBX</code>保存</li>
</ul>
<p>OPCODE 102 载入<code>EAX</code>，<code>INT 80h</code> 开调。</p>
<blockquote>
<p>提示：为避免返回的内容过多而充斥屏幕，可在运行程序时使用输出重定向<code>./crawler &gt; index.html</code>来保存服务器响应到一个文件，而不是直接输出到终端上。</p>
</blockquote>
<h3 id="我们的集大成的第叁拾陆个汇编程序百川朝海">我们的集大成的第叁拾陆个汇编程序——百川朝海</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-nasm" data-lang="nasm"><span class="c1">; Crawler</span>
<span class="c1">; Compile with: nasm -f elf crawler.asm</span>
<span class="c1">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 crawler.o -o crawler</span>
<span class="c1">; Run with: ./crawler</span>
<span class="cp"> 
</span><span class="cp">%include    &#39;functions.asm&#39;
</span><span class="cp"></span> 
<span class="k">SECTION</span> <span class="nv">.data</span>
<span class="c1">; our request string</span>
<span class="nf">request</span> <span class="nv">db</span> <span class="s">&#39;GET / HTTP/1.1&#39;</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="s">&#39;Host: 139.162.39.66:80&#39;</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="mh">0Dh</span><span class="p">,</span> <span class="mh">0Ah</span><span class="p">,</span> <span class="mh">0h</span>
 
<span class="k">SECTION</span> <span class="nv">.bss</span>
<span class="nf">buffer</span> <span class="nv">resb</span> <span class="mi">1</span><span class="p">,</span>                  <span class="c1">; variable to store response</span>
 
<span class="k">SECTION</span> <span class="nv">.text</span>
<span class="k">global</span>  <span class="nv">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">xor</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; init eax 0</span>
    <span class="nf">xor</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>            <span class="c1">; init ebx 0</span>
    <span class="nf">xor</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>            <span class="c1">; init edi 0</span>
 
<span class="nl">_socket:</span>
 
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">6</span>              <span class="c1">; push 6 onto the stack (IPPROTO_TCP)</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">1</span>              <span class="c1">; push 1 onto the stack (SOCK_STREAM)</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">2</span>              <span class="c1">; push 2 onto the stack (PF_INET)</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">; move address of arguments into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>              <span class="c1">; invoke subroutine SOCKET (1)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>            <span class="c1">; invoke SYS_SOCKETCALL (kernel opcode 102)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
<span class="nl">_connect:</span>
 
    <span class="nf">mov</span>     <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">; move return value of SYS_SOCKETCALL into edi (file descriptor for new socket, or -1 on error)</span>
    <span class="nf">push</span>    <span class="kt">dword</span> <span class="mh">0x4227a28b</span>    <span class="c1">; push 139.162.39.66 onto the stack IP ADDRESS (reverse byte order)</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mh">0x5000</span>         <span class="c1">; push 80 onto stack PORT (reverse byte order)</span>
    <span class="nf">push</span>    <span class="kt">word</span> <span class="mi">2</span>              <span class="c1">; push 2 dec onto stack AF_INET</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">; move address of stack pointer into ecx</span>
    <span class="nf">push</span>    <span class="kt">byte</span> <span class="mi">16</span>             <span class="c1">; push 16 dec onto stack (arguments length)</span>
    <span class="nf">push</span>    <span class="nb">ecx</span>                 <span class="c1">; push the address of arguments onto stack</span>
    <span class="nf">push</span>    <span class="nb">edi</span>                 <span class="c1">; push the file descriptor onto stack</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">; move address of arguments into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">3</span>              <span class="c1">; invoke subroutine CONNECT (3)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">102</span>            <span class="c1">; invoke SYS_SOCKETCALL (kernel opcode 102)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
<span class="nl">_write:</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">43</span>             <span class="c1">; move 43 dec into edx (length in bytes to write)</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">request</span>        <span class="c1">; move address of our request variable into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>            <span class="c1">; move file descriptor into ebx (created socket file descriptor)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>              <span class="c1">; invoke SYS_WRITE (kernel opcode 4)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
<span class="nl">_read:</span>
 
    <span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="mi">1</span>              <span class="c1">; number of bytes to read (we will read 1 byte at a time)</span>
    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="nv">buffer</span>         <span class="c1">; move the memory address of our buffer variable into ecx</span>
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>            <span class="c1">; move edi into ebx (created socket file descriptor)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">3</span>              <span class="c1">; invoke SYS_READ (kernel opcode 3)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
    <span class="nf">cmp</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">0</span>              <span class="c1">; if return value of SYS_READ in eax is zero, we have reached the end of the file</span>
    <span class="nf">jz</span>      <span class="nv">_close</span>              <span class="c1">; jmp to _close if we have reached the end of the file (zero flag set)</span>
 
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="nv">buffer</span>         <span class="c1">; move the memory address of our buffer variable into eax for printing</span>
    <span class="nf">call</span>    <span class="nb">sp</span><span class="nv">rint</span>              <span class="c1">; call our string printing function</span>
    <span class="nf">jmp</span>     <span class="nv">_read</span>               <span class="c1">; jmp to _read</span>
 
<span class="nl">_close:</span>
 
    <span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>            <span class="c1">; move edi into ebx (connected socket file descriptor)</span>
    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">6</span>              <span class="c1">; invoke SYS_CLOSE (kernel opcode 6)</span>
    <span class="nf">int</span>     <span class="mh">80h</span>                 <span class="c1">; call the kernel</span>
 
<span class="nl">_exit:</span>
 
    <span class="nf">call</span>    <span class="nv">quit</span>                <span class="c1">; call our quit function</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf crawler.asm
$ ld -m elf_i386 crawler.o -o crawler
$ ./crawler
HTTP/1.1 <span class="m">200</span> OK
Content-Type: text/html
 
&lt;!DOCTYPE html&gt;
&lt;html <span class="nv">lang</span><span class="o">=</span><span class="s2">&#34;en&#34;</span>&gt;
...
&lt;/html&gt;
</code></pre></div><p>$$
The\ End.
$$</p>
<hr>
<p>本文采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名许可协议（CC-BY 4.0）</a>进行许可，转载注明来源即可。如有错误劳烦评论或邮件指出。<img src="../../../images/site/CC-BY_icon.svg" alt="image"></p>
<hr>


        
          <div class="blog-tags">
            
              <a href="https://newlooper.win/tags/assembly-language/">Assembly Language</a>&nbsp;
            
              <a href="https://newlooper.win/tags/nasm/">NASM</a>&nbsp;
            
              <a href="https://newlooper.win/tags/programming/">Programming</a>&nbsp;
            
          </div>
        

        

        
          
            
          

          
                  <h4 class="see-also">也可以看看</h4>
                  <ul>
                
                
                    <li><a href="../../../post/original/cs/io/eof/">EOF，到底怎么回事</a></li>
                
                    <li><a href="../../../post/original/cs/math/permutation/">邻位对换法生成全排列</a></li>
                
              </ul>

          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://newlooper.win/post/original/cs/vm/wsl/migrate_distributions/" data-toggle="tooltip" data-placement="top" title="WSL2 迁移 Linux 发行版">&larr; 前一篇</a>
            </li>
          
          
            <li class="next">
              <a href="https://newlooper.win/post/original/cs/io/eof/" data-toggle="tooltip" data-placement="top" title="EOF，到底怎么回事">后一篇 &rarr;</a>
            </li>
          
        </ul>
      


      
        
          
          <div class="disqus-comments">                  
            <button id="show-comments" class="btn btn-default" type="button">显示 <span class="disqus-comment-count" data-disqus-url="https://newlooper.win/post/trans/learn-assembly-language">则评论</span></button>
            <div id="disqus_thread"></div>

            <script type="text/javascript">
              var disqus_config = function () {
              this.page.url = 'https:\/\/newlooper.win\/post\/trans\/learn-assembly-language';
            };

          </script>
          </div>
          
        
        
      

    </div>
  </div>
</div>

      
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="mailto:newlooper@gmail.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://newlooper.github.io">Dylan Cheng</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2020
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://newlooper.win">Looper 的博客</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          由 <a href="https://gohugo.io">Hugo v0.74.3</a> 强力驱动 &nbsp;&bull;&nbsp; 主题 <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> 移植自 <a href="https://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://newlooper.win/js/jquery.min.js"></script>
<script src="https://newlooper.win/js/bootstrap.min.js"></script>

<script src="https://newlooper.win/js/main.js"></script><script src="https://newlooper.win/js/photoswipe.min.js"></script>
<script src="https://newlooper.win/js/photoswipe-ui-default.min.js"></script><script src="https://newlooper.win/js/load-photoswipe.js"></script>








<script type="text/javascript">
$(function(){
  $('#show-comments').on('click', function(){
    var disqus_shortname = 'newlooper';
      
    (function() {
      var disqus = document.createElement('script'); 
      disqus.type = 'text/javascript'; 
      disqus.async = true;
      disqus.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(disqus);
    })();
      
    $(this).hide(); 
    });
  });
      
</script>
<script id="dsq-count-scr" src="//newlooper.disqus.com/count.js" async></script>




    
  </body>
</html>

