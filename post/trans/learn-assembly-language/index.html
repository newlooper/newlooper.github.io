<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Learn Assembly Language 汇编语言学习(拙译) - Looper 的博客</title>
  <meta name="description" content="Index-0 原址：https://asmtutor.com/
环境：nasm on x64 linux
TL;DR   动机：程序员——多掌握几门计算机语言，还是有好处的
  主题：汇编语言——有其不可替代的作用
  呈示：天下语言逾千——汇编笑看沉舟侧畔
  展开：欲知程序真相——反编译难，反汇编易
  再现：大道器也不器——初见时如茶味甘苦，洞悉后若灌顶醍醐；原以为听多说多皆已昨，忽回首似曾相识又如陌；罢，风流不在谈峰健，相对无言味更长……
    文章作者自己说 This project was put together to teach myself NASM assembly language on linux.
欸~，原来是很窄众的哦。呵呵。
写的虽然通俗，但依然能感到其面向的并不是毫无编程基础的人群，所谓“某子不能隐真恶”，无论怎样努力的将大量概念、原理、知识安排到看似聊天般的文字中，这里都要提醒读者注意，提防因为好奇心而陷入递归学习的泥潭……
  Lesson 1 Hello, world! 背景知识 汇编语言是一种低级语言，汇编程序员与底层硬件之间唯一的接口只有内核本身。用汇编语言编程，涉及到 Linux 内核提供的系统调用机制。这些系统调用是操作系统内置的库函数，提供诸如读取键盘输入以及将输出显示到屏幕之类的功能。
当用户程序发起系统调用时，内核将立即挂起该程序，进而通过驱动程序让相关硬件完成用户程序所发起的任务请求，最后，将控制权交还给用户程序。
 注意：驱动程序的驱动二字，形象的描述了内核对硬件的控制
 在汇编语言中发起系统调用，需要向EAX寄存器写入相应调用的函数编号(也即：操作码OPCODE)，同时设置其他几个寄存器的值作为实际参数，一切准备停当后，指令INT发送一个软中断，内核收到中断请求后接受参数并执行相应的库函数。简单直接。
来写我们的第壹个汇编程序吧——美玉有瑕 还是从著名的例子——$$Hello, world! $$ 开始，我们的汇编程序将把这个让无数程序员产生我已经学会这种语言了的错觉的字符串打印到标准输出上。
首先，在数据段定义一个msg变量，并赋给其一个字符串类型的值作为我们程序的输出。而在代码段中，通过编写全局标签_start:，告诉内核我们(写的诗)程序开始的地方(没有远方)
实际参数通过以下寄存器传给内核：
 EDX存储字符串的长度(字节数) ECX存储字符串的首地址(定义在数据段中的msg变量加载到内存后所在的位置) EBX存储字符串写操作的目标文件——本例中是STDOUT  数据类型和实际参数的含义可以在函数定义中查到。">
  <meta name="author" content="Dylan Cheng"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Looper 的博客",
    
    "url": "https:\/\/newlooper.github.io\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/newlooper.github.io\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/newlooper.github.io\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/newlooper.github.io\/post\/trans\/learn-assembly-language\/",
          "name": "Learn assembly language 汇编语言学习(拙译)"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "Dylan Cheng"
  },
  "headline": "Learn Assembly Language 汇编语言学习(拙译)",
  "description" : "Index-0 原址：https:\/\/asmtutor.com\/\n环境：nasm on x64 linux\nTL;DR   动机：程序员——多掌握几门计算机语言，还是有好处的\n  主题：汇编语言——有其不可替代的作用\n  呈示：天下语言逾千——汇编笑看沉舟侧畔\n  展开：欲知程序真相——反编译难，反汇编易\n  再现：大道器也不器——初见时如茶味甘苦，洞悉后若灌顶醍醐；原以为听多说多皆已昨，忽回首似曾相识又如陌；罢，风流不在谈峰健，相对无言味更长……\n    文章作者自己说 This project was put together to teach myself NASM assembly language on linux.\n欸~，原来是很窄众的哦。呵呵。\n写的虽然通俗，但依然能感到其面向的并不是毫无编程基础的人群，所谓“某子不能隐真恶”，无论怎样努力的将大量概念、原理、知识安排到看似聊天般的文字中，这里都要提醒读者注意，提防因为好奇心而陷入递归学习的泥潭……\n  Lesson 1 Hello, world! 背景知识 汇编语言是一种低级语言，汇编程序员与底层硬件之间唯一的接口只有内核本身。用汇编语言编程，涉及到 Linux 内核提供的系统调用机制。这些系统调用是操作系统内置的库函数，提供诸如读取键盘输入以及将输出显示到屏幕之类的功能。\n当用户程序发起系统调用时，内核将立即挂起该程序，进而通过驱动程序让相关硬件完成用户程序所发起的任务请求，最后，将控制权交还给用户程序。\n 注意：驱动程序的驱动二字，形象的描述了内核对硬件的控制\n 在汇编语言中发起系统调用，需要向EAX寄存器写入相应调用的函数编号(也即：操作码OPCODE)，同时设置其他几个寄存器的值作为实际参数，一切准备停当后，指令INT发送一个软中断，内核收到中断请求后接受参数并执行相应的库函数。简单直接。\n来写我们的第壹个汇编程序吧——美玉有瑕 还是从著名的例子——$$Hello, world! $$ 开始，我们的汇编程序将把这个让无数程序员产生我已经学会这种语言了的错觉的字符串打印到标准输出上。\n首先，在数据段定义一个msg变量，并赋给其一个字符串类型的值作为我们程序的输出。而在代码段中，通过编写全局标签_start:，告诉内核我们(写的诗)程序开始的地方(没有远方)\n实际参数通过以下寄存器传给内核：\n EDX存储字符串的长度(字节数) ECX存储字符串的首地址(定义在数据段中的msg变量加载到内存后所在的位置) EBX存储字符串写操作的目标文件——本例中是STDOUT  数据类型和实际参数的含义可以在函数定义中查到。",
  "inLanguage" : "zh-cn",
  "wordCount":  4755 ,
  "datePublished" : "2020-08-01T16:29:01",
  "dateModified" : "2020-08-01T16:29:01",
  "image" : "https:\/\/newlooper.github.io\/images\/site\/avatar-icon.png",
  "keywords" : [ "" ],
  "mainEntityOfPage" : "https:\/\/newlooper.github.io\/post\/trans\/learn-assembly-language\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/newlooper.github.io\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/newlooper.github.io\/images\/site\/avatar-icon.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="Learn Assembly Language 汇编语言学习(拙译)" />
<meta property="og:description" content="Index-0 原址：https://asmtutor.com/
环境：nasm on x64 linux
TL;DR   动机：程序员——多掌握几门计算机语言，还是有好处的
  主题：汇编语言——有其不可替代的作用
  呈示：天下语言逾千——汇编笑看沉舟侧畔
  展开：欲知程序真相——反编译难，反汇编易
  再现：大道器也不器——初见时如茶味甘苦，洞悉后若灌顶醍醐；原以为听多说多皆已昨，忽回首似曾相识又如陌；罢，风流不在谈峰健，相对无言味更长……
    文章作者自己说 This project was put together to teach myself NASM assembly language on linux.
欸~，原来是很窄众的哦。呵呵。
写的虽然通俗，但依然能感到其面向的并不是毫无编程基础的人群，所谓“某子不能隐真恶”，无论怎样努力的将大量概念、原理、知识安排到看似聊天般的文字中，这里都要提醒读者注意，提防因为好奇心而陷入递归学习的泥潭……
  Lesson 1 Hello, world! 背景知识 汇编语言是一种低级语言，汇编程序员与底层硬件之间唯一的接口只有内核本身。用汇编语言编程，涉及到 Linux 内核提供的系统调用机制。这些系统调用是操作系统内置的库函数，提供诸如读取键盘输入以及将输出显示到屏幕之类的功能。
当用户程序发起系统调用时，内核将立即挂起该程序，进而通过驱动程序让相关硬件完成用户程序所发起的任务请求，最后，将控制权交还给用户程序。
 注意：驱动程序的驱动二字，形象的描述了内核对硬件的控制
 在汇编语言中发起系统调用，需要向EAX寄存器写入相应调用的函数编号(也即：操作码OPCODE)，同时设置其他几个寄存器的值作为实际参数，一切准备停当后，指令INT发送一个软中断，内核收到中断请求后接受参数并执行相应的库函数。简单直接。
来写我们的第壹个汇编程序吧——美玉有瑕 还是从著名的例子——$$Hello, world! $$ 开始，我们的汇编程序将把这个让无数程序员产生我已经学会这种语言了的错觉的字符串打印到标准输出上。
首先，在数据段定义一个msg变量，并赋给其一个字符串类型的值作为我们程序的输出。而在代码段中，通过编写全局标签_start:，告诉内核我们(写的诗)程序开始的地方(没有远方)
实际参数通过以下寄存器传给内核：
 EDX存储字符串的长度(字节数) ECX存储字符串的首地址(定义在数据段中的msg变量加载到内存后所在的位置) EBX存储字符串写操作的目标文件——本例中是STDOUT  数据类型和实际参数的含义可以在函数定义中查到。">
<meta property="og:image" content="https://newlooper.github.io/images/site/avatar-icon.png" />
<meta property="og:url" content="https://newlooper.github.io/post/trans/learn-assembly-language/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Looper 的博客" />

  <meta name="twitter:title" content="Learn Assembly Language 汇编语言学习(拙译)" />
  <meta name="twitter:description" content="Index-0 原址：https://asmtutor.com/
环境：nasm on x64 linux
TL;DR   动机：程序员——多掌握几门计算机语言，还是有好处的
  主题：汇编语言——有其不可替代的作用
  呈示：天下语言逾千——汇编笑看沉舟侧畔
  展开：欲知程序真相——反编译难，反汇编易
  再现：大道器也不器——初见时如茶味甘苦，洞悉后若灌顶醍醐；原以为听多说多皆已昨，忽回首似 …">
  <meta name="twitter:image" content="https://newlooper.github.io/images/site/avatar-icon.png" />
  <meta name="twitter:card" content="summary" />
  <link href='https://newlooper.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.74.3" />
  <link rel="alternate" href="https://newlooper.github.io/index.xml" type="application/rss+xml" title="Looper 的博客"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://newlooper.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" /><link rel="stylesheet" href="https://newlooper.github.io/css/syntax.css" /><link rel="stylesheet" href="https://newlooper.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous"><style>
.container {
    width: 1400px;
    min-width: 1400px;
}
</style>



  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">切换导航</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://newlooper.github.io/">Looper 的博客</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        

        

        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Looper 的博客" href="https://newlooper.github.io/">
            <img class="avatar-img" src="https://newlooper.github.io/images/site/avatar-icon.png" alt="Looper 的博客" />
          </a>
        </div>
      </div>
    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>Learn Assembly Language 汇编语言学习(拙译)</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 2020-08-01
  
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;4755&nbsp;个字
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Dylan Cheng
    
  
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <h2 id="index-0">Index-0</h2>
<p>原址：https://asmtutor.com/<br>
环境：nasm on x64 linux</p>
<h2 id="tldr">TL;DR</h2>
<ul>
<li>
<p>动机：程序员——多掌握几门计算机语言，还是有好处的</p>
</li>
<li>
<p>主题：汇编语言——有其不可替代的作用</p>
</li>
<li>
<p>呈示：天下语言逾千——汇编笑看沉舟侧畔</p>
</li>
<li>
<p>展开：欲知程序真相——反编译难，反汇编易</p>
</li>
<li>
<p>再现：大道器也不器——初见时如茶味甘苦，洞悉后若灌顶醍醐；原以为听多说多皆已昨，忽回首似曾相识又如陌；罢，风流不在谈峰健，相对无言味更长……</p>
</li>
</ul>
<hr>
<blockquote>
<p>文章作者自己说 <em>This project was put together to teach myself NASM assembly language on linux.</em></p>
<p>欸~，原来是很窄众的哦。呵呵。</p>
<p>写的虽然通俗，但依然能感到其面向的并不是毫无编程基础的人群，所谓“某子不能隐真恶”，无论怎样努力的将大量概念、原理、知识安排到看似聊天般的文字中，这里都要提醒读者注意，提防因为好奇心而陷入递归学习的泥潭……</p>
</blockquote>
<hr>
<h2 id="lesson-1-hello-world">Lesson 1 Hello, world!</h2>
<h3 id="背景知识">背景知识</h3>
<p>汇编语言是一种<a href="https://zh.wikipedia.org/wiki/%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80">低级语言</a>，汇编程序员与底层硬件之间唯一的接口只有<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>本身。用汇编语言编程，涉及到 Linux 内核提供的<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a>机制。这些系统调用是操作系统内置的库函数，提供诸如读取键盘输入以及将输出显示到屏幕之类的功能。</p>
<p>当用户程序发起系统调用时，内核将立即<a href="https://zh.wikipedia.org/wiki/%E6%8C%82%E8%B5%B7">挂起</a>该程序，进而通过驱动程序让相关硬件完成用户程序所发起的任务请求，最后，将控制权交还给用户程序。</p>
<blockquote>
<p>注意：驱动程序的驱动二字，形象的描述了内核对硬件的控制</p>
</blockquote>
<p>在汇编语言中发起系统调用，需要向<code>EAX</code><a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>写入相应调用的函数编号(也即：操作码<code>OPCODE</code>)，同时设置其他几个寄存器的值作为实际参数，一切准备停当后，指令<code>INT</code>发送一个软<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7">中断</a>，内核收到中断请求后接受参数并执行相应的库函数。简单直接。</p>
<h3 id="来写我们的第壹个汇编程序吧美玉有瑕">来写我们的第壹个汇编程序吧——美玉有瑕</h3>
<p>还是从著名的例子——$$Hello, world! $$ 开始，我们的汇编程序将把这个让无数程序员产生<code>我已经学会这种语言了</code>的错觉的字符串打印到<a href="https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E4%B8%B2%E6%B5%81#%E6%A8%99%E6%BA%96%E8%BC%B8%E5%87%BA_(stdout)">标准输出</a>上。</p>
<p>首先，在数据段定义一个<code>msg</code>变量，并赋给其一个字符串类型的值作为我们程序的输出。而在代码段中，通过编写全局标签<code>_start:</code>，告诉内核我们(写的诗)程序开始的地方(没有远方)</p>
<p>实际参数通过以下寄存器传给内核：</p>
<ul>
<li><code>EDX</code>存储字符串的长度(字节数)</li>
<li><code>ECX</code>存储字符串的首地址(定义在数据段中的<code>msg</code>变量加载到内存后所在的位置)</li>
<li><code>EBX</code>存储字符串写操作的目标文件——本例中是<code>STDOUT</code></li>
</ul>
<p>数据类型和实际参数的含义可以在函数定义中查到。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp"># https:</span><span class="c1">//github.com/torvalds/linux/blob/master/include/linux/syscalls.h
</span><span class="c1"></span><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div><p>接下来，编译、链接、运行程序</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Hello World Program - asmtutor.com
</span><span class="c">; Compile with: nasm -f elf helloworld.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld
</span><span class="c">; Run with: ./helloworld
</span><span class="c"></span> 
<span class="nf">SECTION</span> <span class="no">.data</span>
<span class="nf">msg</span>     <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Hello</span> <span class="no">World</span><span class="p">!</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">Ah</span>     <span class="c">; assign msg variable with your message string
</span><span class="c"></span> 
<span class="no">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">edx</span><span class="p">,</span> <span class="mi">13</span>     <span class="c">; number of bytes to write - one for each letter plus 0Ah (line feed character)
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="no">msg</span>    <span class="c">; move the memory address of our message string into ecx
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">1</span>      <span class="c">; write to the STDOUT file
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">4</span>      <span class="c">; invoke SYS_WRITE (kernel opcode 4)
</span><span class="c"></span>    <span class="no">int</span>     <span class="mi">80</span><span class="no">h</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld.asm
$ ld -m elf_i386 helloworld.o -o helloworld
$ ./helloworld
Hello World!
Segmentation fault
</code></pre></div><blockquote>
<p>注意，系统报告了错误：Segmentation fault</p>
</blockquote>
<hr>
<h2 id="lesson-2-程序退出的正确姿势">Lesson 2 程序退出的正确姿势</h2>
<h3 id="若干背景知识">若干背景知识</h3>
<p>让我们从第一课成功发起系统调用的短暂喜悦中回过神来，学习内核中另一个最重要的系统调用<code>sys_exit</code></p>
<p>还记得，上一课中，我们的程序运行并打印了 $$Hello, world!$$ 字符串后，还看到了一句<code>Segmentation fault</code>？</p>
<p>嘛，计算机程序可看作是装载到内存中且被分割成若干节(或段)的一长条的<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4">指令</a>序列，这个通用的内存池实际上被所有程序共享，保存着变量、指令，其他程序等等……每一个段都有一个地址，以便其中存储的二进制信息之后的定位访问。</p>
<p>要执行加载到内存中的程序，我们使用全局标签<code>_start:</code>来告诉操作系统从哪里找到并开始执行我们的程序。从那个位置开始，内存将依据程序的逻辑所决定的下一个地址被依次访问。内核在这些地址上愉悦的跳来跳去，执行着程序。</p>
<p>与告诉内核<strong>一个程序从哪里开始</strong>同样重要的是：<strong>程序在哪里结束</strong>。这正是上一课中我们的程序所缺少的步骤。因为这个重要步骤的缺失，在我们调用完<code>sys_write</code>，内核把控制权交还给我们的程序之后，程序继续顺序执行内存中紧挨在<code>int     80h</code>之后的地址中的&quot;指令&rdquo;(天知道那一刻那里存的是啥)，我们不知道内核将执行什么指令，但显然在我们的例子中内核噎住了，并且不高兴(非正常)的替我们终止了进程，严肃的招待了我们一个：<code>Segmentation fault</code></p>
<p>在程序的末尾调用<code>sys_exit</code>吧！</p>
<h3 id="开写我们的第贰个汇编程序善始善终">开写我们的第贰个汇编程序——善始善终</h3>
<p><code>sys_exit</code>的定义简单明了。在 Linux 系统调用表中，操作码<code>OPCODE 1</code>被分配给了她，同时她比<code>sys_write</code>节省一些，调用她只需要传一个实参</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp"># https:</span><span class="c1">//github.com/torvalds/linux/blob/master/include/linux/syscalls.h
</span><span class="c1"></span><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">error_code</span><span class="p">);</span>
</code></pre></div><p>她要被要这样调：</p>
<ul>
<li><code>EBX</code>里存<code>0</code>意为<code>零个错误</code></li>
<li><code>EAX</code>当然就存<code>1</code>了 (sys_exit 的 OPCODE)</li>
<li>然后，软中断<code>INT 80h</code>和上一个例子一样</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Hello World Program - asmtutor.com
</span><span class="c">; Compile with: nasm -f elf helloworld.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld
</span><span class="c">; Run with: ./helloworld
</span><span class="c"></span> 
<span class="nf">SECTION</span> <span class="no">.data</span>
<span class="nf">msg</span>     <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Hello</span> <span class="no">World</span><span class="p">!</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">Ah</span>
 
<span class="nf">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">edx</span><span class="p">,</span> <span class="mi">13</span>
    <span class="nf">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="no">msg</span>
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mi">80</span><span class="no">h</span>
 
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">0</span>      <span class="c">; return 0 status on exit - &#39;No Errors&#39;
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c">; invoke SYS_EXIT (kernel opcode 1)
</span><span class="c"></span>    <span class="no">int</span>     <span class="mi">80</span><span class="no">h</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld.asm
$ ld -m elf_i386 helloworld.o -o helloworld
$ ./helloworld
Hello World!
</code></pre></div><p>$$We\ will\ meet\ again,\ Segmentation\ fault$$</p>
<hr>
<h2 id="lesson-3-计算字符串长度">Lesson 3 计算字符串长度</h2>
<h3 id="又一些背景知识">又一些背景知识</h3>
<p>为什么需要计算字符串的长度？</p>
<p>嘛，<code>sys_write</code>必须知道我们传给她的字符串的指针和长度(字节数)，才能够打印输出。如果我们修改了<code>msg</code>字符串的内容，我们也必须相应的更新字符串的长度，否则打印操作将不正确。</p>
<p>为了验证这一点，我们用第二课中的例子。将<code>msg</code>字符串修改为：(中括号帮助标识边界用)
$$[Hello,\ brave\ new\ world!]$$
编译、链接、执行修改后的程序。输出变为：
$$[Hello,\ brave\ ]$$
(仅有前 13 个 ascii 字符，空格也算)，这是因为我们没有将长度实参的值从原来的 13，更新为新字符串长度 23</p>
<h3 id="我们的第叁个汇编程序登场魔尺道丈">我们的第叁个汇编程序登场——魔尺道丈</h3>
<p>要计算某个字符串的长度，这里引入一种称作<a href="https://www.tutorialspoint.com/cprogramming/c_pointer_arithmetic.htm">指针算数</a>的技术。具体步骤为：</p>
<ul>
<li>选两个寄存器初始化为相同的内存地址</li>
<li>用其中一个寄存器(本例中使用<code>EAX</code>)遍历要输出的字符串中的字符，在每次遇到 1 个字符的时候给自己加 1，直到其遇到一个代表字符串结尾的特殊字符</li>
<li>此时用<code>EAX</code>减去一开始初始化为相同值的另一个寄存器的值，结果就是字符的个数</li>
</ul>
<p>有点像两个数组做减法，差表示了两个地址之间的元素的个数。我们用这个差值替代旧例子中的<a href="https://zh.wikipedia.org/wiki/%E5%AF%AB%E6%AD%BB">硬编码</a>值，传递给<code>sys_write</code></p>
<p>汇编程序中，通常用<code>CMP</code>指令进行某种判断，根据其两个操作数的比较结果来置位标志寄存器，后续指令根据标志寄存器的值来决定如何推进程序的流程。</p>
<p>在接下来的代码中，我们关注的是<code>ZF (Zero Flag)</code>标志寄存器。如果<code>EAX</code>寄存器中的地址所指向的字符 ascii 值等于 0，则<code>ZF</code>被置位。而后<code>JZ</code>指令看到<code>ZF</code>为 1，就跳转到其操作数所指明的位置(流程改变)，这个跳转为的是退出 nextchar 循环从而执行后续的程序代码</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Hello World Program (Calculating string length)
</span><span class="c">; Compile with: nasm -f elf helloworld-len.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len
</span><span class="c">; Run with: ./helloworld-len
</span><span class="c"></span> 
<span class="nf">SECTION</span> <span class="no">.data</span>
<span class="nf">msg</span>     <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Hello</span><span class="p">,</span> <span class="no">brave</span> <span class="no">new</span> <span class="no">world</span><span class="p">!</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">Ah</span> <span class="c">; we can modify this now without having to update anywhere else in the program
</span><span class="c"></span> 
<span class="no">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="no">msg</span>        <span class="c">; move the address of our message string into EBX
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ebx</span>        <span class="c">; move the address in EBX into EAX as well (Both now point to the same segment in memory)
</span><span class="c"></span> 
<span class="no">nextchar</span><span class="p">:</span>
    <span class="nf">cmp</span>     <span class="no">byte</span> <span class="p">[</span><span class="no">eax</span><span class="p">],</span> <span class="mi">0</span>   <span class="c">; compare the byte pointed to by EAX at this address against zero (Zero is an end of string delimiter)
</span><span class="c"></span>    <span class="no">jz</span>      <span class="no">finished</span>        <span class="c">; jump (if the zero flagged has been set) to the point in the code labeled &#39;finished&#39;
</span><span class="c"></span>    <span class="no">inc</span>     <span class="no">eax</span>             <span class="c">; increment the address in EAX by one byte (if the zero flagged has NOT been set)
</span><span class="c"></span>    <span class="no">jmp</span>     <span class="no">nextchar</span>        <span class="c">; jump to the point in the code labeled &#39;nextchar&#39;
</span><span class="c"></span> 
<span class="no">finished</span><span class="p">:</span>
    <span class="nf">sub</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ebx</span>        <span class="c">; subtract the address in EBX from the address in EAX
</span><span class="c"></span>                            <span class="c">; remember both registers started pointing to the same address (see line 15)
</span><span class="c"></span>                            <span class="c">; but EAX has been incremented one byte for each character in the message string
</span><span class="c"></span>                            <span class="c">; when you subtract one memory address from another of the same type
</span><span class="c"></span>                            <span class="c">; the result is number of segments between them - in this case the number of bytes
</span><span class="c"></span> 
    <span class="no">mov</span>     <span class="no">edx</span><span class="p">,</span> <span class="no">eax</span>        <span class="c">; EAX now equals the number of bytes in our string
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="no">msg</span>        <span class="c">; the rest of the code should be familiar now
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mi">80</span><span class="no">h</span>
 
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">int</span>     <span class="mi">80</span><span class="no">h</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-len.asm
$ ld -m elf_i386 helloworld-len.o -o helloworld-len
$ ./helloworld-len
Hello, brave new world!
</code></pre></div><hr>
<h2 id="lesson-4-子例程">Lesson 4 子例程</h2>
<h3 id="引入子例程">引入子例程</h3>
<p>子例程——函数也。他们是可复用的代码片段，能够被用户程序调用完成各种各样的任务。和前面定义程序入口点一样，子例程也通过定义标签来声明其起始位置(如<code>strlen:</code>)，然而不同之处在于程序不使用<code>JMP</code>指令来访问子例程，取而代之的是使用<code>CALL</code>指令。同样，子例程执行完成后的跳转回地址也不使用<code>JMP</code>而是使用<code>RET</code>。</p>
<p>同样是跳转到指令的所在处(memory address)，为什么子例程不使用<code>JMP</code>呢？</p>
<p>子例程的威力在于其可复用性，想在程序中的任意位置随时调用子例程，除了要跳转到子例程所在的地址外，还必须要编写一些逻辑来确定子例程运行完后跳转回的位置，如果使用<code>JMP</code>将导致我们的代码中到处是非必要的标签。而使用<code>CALL</code>和<code>RET</code>，汇编语言将采用称作<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88">堆栈</a>的机制代为处理这些细节。</p>
<h3 id="引入栈">引入栈</h3>
<p>栈也在内存中，然而某个程序的栈内存对其而言具备一些特殊性质。栈内存的存取遵循<a href="https://zh.wikipedia.org/wiki/%E5%85%88%E9%80%B2%E5%85%88%E5%87%BA%E5%92%8C%E5%BE%8C%E9%80%B2%E5%85%88%E5%87%BA%E6%9C%83%E8%A8%88%E6%B3%95">后进先出</a> Last In First Out memory (LIFO)原则。可以将其想象成厨房中的一摞碟子，最后一个放在顶上的碟子也正是下一次用碟子时第一个被取走的。</p>
<p>诚然，汇编中的栈内存放不下碟子，但是能放二进制数据。变量、地址、甚至其他程序都可以放进去。当调用子例程时，我们需要使用栈来临时存放上述数据以便子例程使用。</p>
<p>通常，执行中的一段代码所使用着的任何寄存器，都应该在调用子例程之前，使用<code>PUSH</code>指令将其中的数据压入栈，以此确保子例程返回后可以还原这些寄存器的原有值(因为子例程有可能会使用上述寄存器存储新的数据，不预先保存的话被覆盖后就丢失了)，还原通过与<code>PUSH</code>指令执行顺序相反的顺序执行<code>POP</code>指令来完成。如此，就不必担心子例程执行过程中对上述寄存的修改。</p>
<p><code>CALL</code>和<code>RET</code>两个指令与<code>PUSH</code>和<code>POP</code>相似，也使用到了堆栈，但他们除了压栈/弹栈外还做了额外的工作，当<code>CALL</code>一个子例程时，<code>CALL</code>指令所在位置的下一个内存地址(return address)被压入栈，同时子例程所在地址被存入<code>EIP</code>。这个存在栈内存中的地址(return address)将由在子例程中的<code>RET</code>指令弹给<code>EIP</code>从而跳转回调用者的代码继续执行。希望这段描述能够些许的消除【内联标签使用<code>JMP</code>，而子例程(函数)调用使用<code>CALL</code>】的疑惑。</p>
<h3 id="我们的第肆个汇编程序管中窥豹">我们的第肆个汇编程序——管中窥豹</h3>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Hello World Program (Subroutines)
</span><span class="c">; Compile with: nasm -f elf helloworld-len.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len
</span><span class="c">; Run with: ./helloworld-len
</span><span class="c"></span> 
<span class="nf">SECTION</span> <span class="no">.data</span>
<span class="nf">msg</span>     <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Hello</span><span class="p">,</span> <span class="no">brave</span> <span class="no">new</span> <span class="no">world</span><span class="p">!</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">Ah</span>
 
<span class="nf">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg</span>        <span class="c">; move the address of our message string into EAX
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">strlen</span>          <span class="c">; call our function to calculate the length of the string
</span><span class="c"></span> 
    <span class="no">mov</span>     <span class="no">edx</span><span class="p">,</span> <span class="no">eax</span>        <span class="c">; our function leaves the result in EAX
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="no">msg</span>        <span class="c">; this is all the same as before
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mi">80</span><span class="no">h</span>
 
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">int</span>     <span class="mi">80</span><span class="no">h</span>
 
<span class="nl">strlen:</span>                     <span class="c">; this is our first function declaration
</span><span class="c"></span>    <span class="nf">push</span>    <span class="no">ebx</span>             <span class="c">; push the value in EBX onto the stack to preserve it while we use EBX in this function
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="no">eax</span>        <span class="c">; move the address in EAX into EBX (Both point to the same segment in memory)
</span><span class="c"></span> 
<span class="no">nextchar</span><span class="p">:</span>                   <span class="c">; this is the same as lesson3
</span><span class="c"></span>    <span class="no">cmp</span>     <span class="no">byte</span> <span class="p">[</span><span class="no">eax</span><span class="p">],</span> <span class="mi">0</span>
    <span class="nf">jz</span>      <span class="no">finished</span>
    <span class="nf">inc</span>     <span class="no">eax</span>
    <span class="nf">jmp</span>     <span class="no">nextchar</span>
 
<span class="nl">finished:</span>
    <span class="nf">sub</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ebx</span>
    <span class="nf">pop</span>     <span class="no">ebx</span>             <span class="c">; pop the value on the stack back into EBX
</span><span class="c"></span>    <span class="no">ret</span>                     <span class="c">; return to where the function was called
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-len.asm
$ ld -m elf_i386 helloworld-len.o -o helloworld-len
$ ./helloworld-len
Hello, brave new world!
</code></pre></div><hr>
<h2 id="lesson-5-外部包含文件">Lesson 5 外部包含文件</h2>
<p>外部包含文件使得我们能够将程序的代码分散不同文件中。对于撰写清晰、易维护的程序来说这个技术很有用。可重用代码能够写成子例程保存在分散的文件中，这类文件被称为库。当你想使用库中的某段代码时，包含该库文件到你的程序，就好像该文件的内容是就是你程序的一部分一样。</p>
<p>本节我们把计算字符串长度的子例程移到外部文件中。同时，我们将字符串打印和程序退出逻辑也都修缮为子例程一并移到外部文件里。如此，我们瘦身后的程序看起来更加清晰、易读。</p>
<p>我们多声明一条消息，调用两次字符串打印子例程来演示对代码的复用。</p>
<blockquote>
<p>注意：之后的课程中，除非 functions.asm 发生了改变，否则其代码将被省略</p>
</blockquote>
<h3 id="我们的第伍个汇编程序他山之石">我们的第伍个汇编程序——他山之石</h3>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">;------------------------------------------
</span><span class="c">; functions.asm
</span><span class="c">;
</span><span class="c"></span>
<span class="c">; int slen(String message)
</span><span class="c">; String length calculation function
</span><span class="c"></span><span class="nl">slen:</span>
    <span class="nf">push</span>    <span class="no">ebx</span>
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="no">eax</span>
 
<span class="nl">nextchar:</span>
    <span class="nf">cmp</span>     <span class="no">byte</span> <span class="p">[</span><span class="no">eax</span><span class="p">],</span> <span class="mi">0</span>
    <span class="nf">jz</span>      <span class="no">finished</span>
    <span class="nf">inc</span>     <span class="no">eax</span>
    <span class="nf">jmp</span>     <span class="no">nextchar</span>
 
<span class="nl">finished:</span>
    <span class="nf">sub</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ebx</span>
    <span class="nf">pop</span>     <span class="no">ebx</span>
    <span class="nf">ret</span>
 
 
<span class="c">;------------------------------------------
</span><span class="c">; void sprint(String message)
</span><span class="c">; String printing function
</span><span class="c"></span><span class="nl">sprint:</span>
    <span class="nf">push</span>    <span class="no">edx</span>
    <span class="nf">push</span>    <span class="no">ecx</span>
    <span class="nf">push</span>    <span class="no">ebx</span>
    <span class="nf">push</span>    <span class="no">eax</span>
    <span class="nf">call</span>    <span class="no">slen</span>
 
    <span class="nf">mov</span>     <span class="no">edx</span><span class="p">,</span> <span class="no">eax</span>
    <span class="nf">pop</span>     <span class="no">eax</span>
 
    <span class="nf">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="no">eax</span>
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mi">80</span><span class="no">h</span>
 
    <span class="nf">pop</span>     <span class="no">ebx</span>
    <span class="nf">pop</span>     <span class="no">ecx</span>
    <span class="nf">pop</span>     <span class="no">edx</span>
    <span class="nf">ret</span>
 
 
<span class="c">;------------------------------------------
</span><span class="c">; void exit()
</span><span class="c">; Exit program and restore resources
</span><span class="c"></span><span class="nl">quit:</span>
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">int</span>     <span class="mi">80</span><span class="no">h</span>
    <span class="nf">ret</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Hello World Program (External file include)
</span><span class="c">; Compile with: nasm -f elf helloworld-inc.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc
</span><span class="c">; Run with: ./helloworld-inc
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>                             <span class="c">; include our external file
</span><span class="c"></span> 
<span class="no">SECTION</span> <span class="no">.data</span>
<span class="nf">msg1</span>    <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Hello</span><span class="p">,</span> <span class="no">brave</span> <span class="no">new</span> <span class="no">world</span><span class="p">!</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">Ah</span>              <span class="c">; our first message string
</span><span class="c"></span><span class="no">msg2</span>    <span class="no">db</span>      <span class="err">&#39;</span><span class="no">This</span> <span class="no">is</span> <span class="no">how</span> <span class="no">we</span> <span class="no">recycle</span> <span class="no">in</span> <span class="no">NASM.</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">Ah</span>      <span class="c">; our second message string
</span><span class="c"></span> 
<span class="no">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg1</span>       <span class="c">; move the address of our first message string into EAX
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprint</span>          <span class="c">; call our string printing function
</span><span class="c"></span> 
    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg2</span>       <span class="c">; move the address of our second message string into EAX
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprint</span>          <span class="c">; call our string printing function
</span><span class="c"></span> 
    <span class="no">call</span>    <span class="no">quit</span>            <span class="c">; call our quit function
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-inc.asm
$ ld -m elf_i386 helloworld-inc.o -o helloworld-inc
$ ./helloworld-inc
Hello, brave new world!
This is how we recycle in NASM.
This is how we recycle in NASM.
</code></pre></div><blockquote>
<p>错误：貌似第二条消息被打印了两次，我们在下节课修正:-)</p>
</blockquote>
<hr>
<h2 id="lesson-6-null-终止符">Lesson 6 NULL 终止符</h2>
<p>好吧，上一节的结尾我用“貌似”二字修饰了<code>msg2</code>被打印了两次这一现象，实际上程序并没有逻辑错误，她忠实的履行了职责，完成了我们的任务委托，也即：我们上一节的代码写法，输出就应该是那样子的。解释现象之前，我们先分别注释掉打印<code>msg1</code>或<code>msg2</code>的代码，只留其中一个看看效果</p>
<p>如果，只注释<code>msg1</code>的打印指令，</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">;   mov     eax, msg1       ; move the address of our first message string into EAX
</span><span class="c">;   call    sprint          ; call our string printing function
</span><span class="c"></span>    
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg2</span>       <span class="c">; move the address of our second message string into EAX
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprint</span>          <span class="c">; call our string printing function
</span></code></pre></div><p>输出为：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">This is how we recycle in NASM.
</code></pre></div><p>输出和我们预期的相符。</p>
<p>如果，只注释<code>msg2</code>的打印指令，</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm">    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg1</span>       <span class="c">; move the address of our first message string into EAX
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprint</span>          <span class="c">; call our string printing function
</span><span class="c"></span>    
<span class="c">;   mov     eax, msg2       ; move the address of our second message string into EAX
</span><span class="c">;   call    sprint          ; call our string printing function
</span></code></pre></div><p>输出为：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Hello, brave new world!
This is how we recycle in NASM.
</code></pre></div><p>等一下，打印<code>msg1</code>的指令，怎么把第二个字符串也打印了？</p>
<p>答案在于，对于<code>msg1</code>字符串，我们没有给出明确的结尾。在数据段中的两条相邻的<code>db</code>代码，内存的分配也是相邻的，因此，<code>msg1</code>字符串的最后一个字节紧挨着<code>msg2</code>的第一个字节。记得之前，我们计算字符串长度所采用的方法——通过比较值为 0 的字节作为结尾！Lesson 5 的代码在运行到计算<code>msg1</code>的长度时，子例程读完了所有<code>msg1</code>的字节后，并没有遇到值为 0 的字节，所以她认为这个字符串还没完，程序继续从<code>msg2</code>的第一个字节逐个比较，直到<code>msg2</code>的所有字节也读完了，才找到字符串结尾。</p>
<p>因此看上去<code>msg2</code>被打印两次，实际上是视觉上的问题，实际的输出过程是：</p>
<p>先输出了<code>Hello, brave new world!\nThis is how we recycle in NASM.\n</code>
又输出了<code>This is how we recycle in NASM.\n</code></p>
<p>再等一下，你或许会问，<code>msg2</code>我也没看到有字符串结尾啊？被你逮到了:-)这是因为数据段的内存在开辟时，都被初始化成了 0h。</p>
<h3 id="我们的第陆个汇编程序楚河汉界">我们的第陆个汇编程序——楚河汉界</h3>
<blockquote>
<p>注意：汇编程序中，用 0h 表示 NULL 字节，而 NULL 字节标识了字符串的结尾</p>
</blockquote>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Hello World Program (NULL terminating bytes)
</span><span class="c">; Compile with: nasm -f elf helloworld-inc.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc
</span><span class="c">; Run with: ./helloworld-inc
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.data</span>
<span class="nf">msg1</span>    <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Hello</span><span class="p">,</span> <span class="no">brave</span> <span class="no">new</span> <span class="no">world</span><span class="p">!</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">Ah</span><span class="p">,</span> <span class="mi">0</span><span class="no">h</span>          <span class="c">; NOTE the null terminating byte
</span><span class="c"></span><span class="no">msg2</span>    <span class="no">db</span>      <span class="err">&#39;</span><span class="no">This</span> <span class="no">is</span> <span class="no">how</span> <span class="no">we</span> <span class="no">recycle</span> <span class="no">in</span> <span class="no">NASM.</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">Ah</span><span class="p">,</span> <span class="mi">0</span><span class="no">h</span>  <span class="c">; NOTE the null terminating byte
</span><span class="c"></span> 
<span class="no">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg1</span>
    <span class="nf">call</span>    <span class="no">sprint</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg2</span>
    <span class="nf">call</span>    <span class="no">sprint</span>
 
    <span class="nf">call</span>    <span class="no">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-inc.asm
$ ld -m elf_i386 helloworld-inc.o -o helloworld-inc
$ ./helloworld-inc
Hello, brave new world!
This is how we recycle in NASM.
</code></pre></div><hr>
<h2 id="lesson-7-换行">Lesson 7 换行</h2>
<p>换行的重要性对于控制台程序而言是不言而喻的，尤其是构建需要用户输入的程序时，更是如此。但是换行又是难以摆弄的，处理字符串时有时需要包含换行，有时又需要去掉他。如果我们始终把表示换行符的 ascii 码 0Ah 硬编码在我们的变量中，就要面对一个问题——在不需要输出换行符的地方得写额外的代码来去掉他。</p>
<p>如果有个专门的子例程输出我们指定的字符串，由该子例程负责在结尾打印一个换行符。就可以在需要打印换行符的地方调用这个子例程，而在不需要打印换行符的地方还使用我们的<code>sprint</code>子例程就可以了。</p>
<p>记得前文中，想调用<code>sys_write</code>必须提供要打印内容的地址及其长度，所以仅仅传递换行符是不够的，同时我们也不想仅仅为了这一个字符单独定义一个变量来保存他，我们决定使用栈内存来实现新的子例程。</p>
<p>招法如下：</p>
<ul>
<li>换行符存进<code>EAX</code></li>
<li><code>PUSH EAX</code>的值到栈上，并获取<code>ESP</code>的值(当前栈顶所在的地址)</li>
<li>通过当前的<code>ESP</code>知道了换行符所在内存地址，那么调用<code>sys_write</code>的必要条件已然具备</li>
</ul>
<h3 id="且看我们的第柒个汇编程序路转峰回">且看我们的第柒个汇编程序——路转峰回</h3>
<blockquote>
<p>注意：观察 functions.asm 中的 sprintLF 子例程</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">;------------------------------------------
</span><span class="c">; int slen(String message)
</span><span class="c">; String length calculation function
</span><span class="c"></span><span class="nl">slen:</span>
    <span class="nf">push</span>    <span class="no">ebx</span>
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="no">eax</span>
 
<span class="nl">nextchar:</span>
    <span class="nf">cmp</span>     <span class="no">byte</span> <span class="p">[</span><span class="no">eax</span><span class="p">],</span> <span class="mi">0</span>
    <span class="nf">jz</span>      <span class="no">finished</span>
    <span class="nf">inc</span>     <span class="no">eax</span>
    <span class="nf">jmp</span>     <span class="no">nextchar</span>
 
<span class="nl">finished:</span>
    <span class="nf">sub</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ebx</span>
    <span class="nf">pop</span>     <span class="no">ebx</span>
    <span class="nf">ret</span>
 
 
<span class="c">;------------------------------------------
</span><span class="c">; void sprint(String message)
</span><span class="c">; String printing function
</span><span class="c"></span><span class="nl">sprint:</span>
    <span class="nf">push</span>    <span class="no">edx</span>
    <span class="nf">push</span>    <span class="no">ecx</span>
    <span class="nf">push</span>    <span class="no">ebx</span>
    <span class="nf">push</span>    <span class="no">eax</span>
    <span class="nf">call</span>    <span class="no">slen</span>
 
    <span class="nf">mov</span>     <span class="no">edx</span><span class="p">,</span> <span class="no">eax</span>
    <span class="nf">pop</span>     <span class="no">eax</span>
 
    <span class="nf">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="no">eax</span>
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mi">80</span><span class="no">h</span>
 
    <span class="nf">pop</span>     <span class="no">ebx</span>
    <span class="nf">pop</span>     <span class="no">ecx</span>
    <span class="nf">pop</span>     <span class="no">edx</span>
    <span class="nf">ret</span>
 
 
<span class="c">;------------------------------------------
</span><span class="c">; void sprintLF(String message)
</span><span class="c">; String printing with line feed function
</span><span class="c"></span><span class="nl">sprintLF:</span>
    <span class="nf">call</span>    <span class="no">sprint</span>
 
    <span class="nf">push</span>    <span class="no">eax</span>         <span class="c">; push eax onto the stack to preserve it while we use the eax register in this function
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">0</span><span class="no">Ah</span>    <span class="c">; move 0Ah into eax - 0Ah is the ascii character for a linefeed
</span><span class="c"></span>    <span class="no">push</span>    <span class="no">eax</span>         <span class="c">; push the linefeed onto the stack so we can get the address
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">esp</span>    <span class="c">; move the address of the current stack pointer into eax for sprint
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprint</span>      <span class="c">; call our sprint function
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">eax</span>         <span class="c">; remove our linefeed character from the stack
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">eax</span>         <span class="c">; restore the original value of eax before our function was called
</span><span class="c"></span>    <span class="no">ret</span>                 <span class="c">; return to our program
</span><span class="c"></span> 
 
<span class="c">;------------------------------------------
</span><span class="c">; void exit()
</span><span class="c">; Exit program and restore resources
</span><span class="c"></span><span class="no">quit</span><span class="p">:</span>
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">int</span>     <span class="mi">80</span><span class="no">h</span>
    <span class="nf">ret</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Hello World Program (Print with line feed)
</span><span class="c">; Compile with: nasm -f elf helloworld-lf.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-lf.o -o helloworld-lf
</span><span class="c">; Run with: ./helloworld-lf
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.data</span>
<span class="nf">msg1</span>    <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Hello</span><span class="p">,</span> <span class="no">brave</span> <span class="no">new</span> <span class="no">world</span><span class="p">!</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">h</span>          <span class="c">; NOTE we have removed the line feed character 0Ah
</span><span class="c"></span><span class="no">msg2</span>    <span class="no">db</span>      <span class="err">&#39;</span><span class="no">This</span> <span class="no">is</span> <span class="no">how</span> <span class="no">we</span> <span class="no">recycle</span> <span class="no">in</span> <span class="no">NASM.</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">h</span>  <span class="c">; NOTE we have removed the line feed character 0Ah
</span><span class="c"></span> 
<span class="no">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg1</span>
    <span class="nf">call</span>    <span class="no">sprintLF</span>    <span class="c">; NOTE we are calling our new print with linefeed function
</span><span class="c"></span> 
    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg2</span>
    <span class="nf">call</span>    <span class="no">sprintLF</span>    <span class="c">; NOTE we are calling our new print with linefeed function
</span><span class="c"></span> 
    <span class="no">call</span>    <span class="no">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-lf.asm
$ ld -m elf_i386 helloworld-lf.o -o helloworld-lf
$ ./helloworld-lf
Hello, brave new world!
This is how we recycle in NASM.
</code></pre></div><hr>
<h2 id="lesson-8-命令行参数">Lesson 8 命令行参数</h2>
<p>在 NASM 中，接收命令行参数也使用堆栈。程序启动时，所有参数被反序的压入堆栈，然后程序名被压入栈，最后是参数的个数被压入栈。对于 NASM 编写的程序，最顶上的两个栈内存单元总是保存着程序名和参数个数。</p>
<p>要处理这些参数，我们所要做的就是执行若干次<code>POP</code>逐个弹出参数信息，然后迭代每一个参数并运行我们的程序逻辑。在本例中，简单的调用<code>sprintLF</code>函数打印输出。</p>
<blockquote>
<p>注意：我们使用<code>ECX</code>寄存器作为循环计数器。这个通用寄存器最初的设计意图就是计数。</p>
</blockquote>
<h3 id="我们的第捌个汇编程序兵来将挡">我们的第捌个汇编程序——兵来将挡</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Hello World Program (Passing arguments from the command line)
</span><span class="c">; Compile with: nasm -f elf helloworld-args.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-args.o -o helloworld-args
</span><span class="c">; Run with: ./helloworld-args
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">pop</span>     <span class="no">ecx</span>             <span class="c">; first value on the stack is the number of arguments
</span><span class="c"></span> 
<span class="no">nextArg</span><span class="p">:</span>
    <span class="nf">cmp</span>     <span class="no">ecx</span><span class="p">,</span> <span class="mi">0</span><span class="no">h</span>         <span class="c">; check to see if we have any arguments left
</span><span class="c"></span>    <span class="no">jz</span>      <span class="no">noMoreArgs</span>      <span class="c">; if zero flag is set jump to noMoreArgs label (jumping over the end of the loop)
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">eax</span>             <span class="c">; pop the next argument off the stack
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprintLF</span>        <span class="c">; call our print with linefeed function
</span><span class="c"></span>    <span class="no">dec</span>     <span class="no">ecx</span>             <span class="c">; decrease ecx (number of arguments left) by 1
</span><span class="c"></span>    <span class="no">jmp</span>     <span class="no">nextArg</span>         <span class="c">; jump to nextArg label
</span><span class="c"></span> 
<span class="no">noMoreArgs</span><span class="p">:</span>
    <span class="nf">call</span>    <span class="no">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-args.asm
$ ld -m elf_i386 helloworld-lf.o -o helloworld-args
$ ./helloworld-args <span class="s2">&#34;This is one argument&#34;</span> <span class="s2">&#34;This is another&#34;</span> <span class="m">101</span>
./helloworld-args
This is one argument
This is another
<span class="m">101</span>
</code></pre></div><hr>
<h2 id="lesson-9-处理用户输出">Lesson 9 处理用户输出</h2>
<h3 id="引入-bss-段">引入 bss 段</h3>
<p>目前为止，我们用到了代码段<code>.text</code>和数据段<code>.data</code>。接下来引入<code>.bss</code>段——全称 BLOCK Started by Symbol。这块内存用来保存我们程序中的未初始化变量。这些预留的空间通常用来存储用户输入的数据，这类数据的特点在于无法在编程时知道其具体的大小。</p>
<p>变量声明语法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">SECTION</span> <span class="no">.bss</span>
<span class="nl">variableName1:</span>      <span class="nf">RESB</span>    <span class="mi">1</span>       <span class="c">; reserve space for 1 byte
</span><span class="c"></span><span class="no">variableName2</span><span class="p">:</span>      <span class="no">RESW</span>    <span class="mi">1</span>       <span class="c">; reserve space for 1 word
</span><span class="c"></span><span class="no">variableName3</span><span class="p">:</span>      <span class="no">RESD</span>    <span class="mi">1</span>       <span class="c">; reserve space for 1 double word
</span><span class="c"></span><span class="no">variableName4</span><span class="p">:</span>      <span class="no">RESQ</span>    <span class="mi">1</span>       <span class="c">; reserve space for 1 double precision float (quad word)
</span><span class="c"></span><span class="no">variableName5</span><span class="p">:</span>      <span class="no">REST</span>    <span class="mi">1</span>       <span class="c">; reserve space for 1 extended precision float
</span></code></pre></div><h3 id="这是我们的第玖个汇编程序不预则废">这是我们的第玖个汇编程序——不预则废</h3>
<p>是时候引入另一个重要的系统调用<code>sys_read</code>了，让用户输入来的更猛烈些吧。在 Linux 系统调用表中，此函数的<code>OPCODE 3</code>。和<code>sys_write</code>一样也接收3个参数，详情如下：</p>
<ul>
<li><code>EDX</code>载入读取的最大长度(以字节为单位)</li>
<li><code>ECX</code>载入<code>.bss</code>中创建的变量的地址</li>
<li><code>EBX</code>载入我们要读取的文件描述符(在本例中为STDIN)</li>
</ul>
<p>同样，函数参数的数据类型和含义可在行数定义中找到</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp"># https:</span><span class="c1">//github.com/torvalds/linux/blob/master/include/linux/syscalls.h
</span><span class="c1"></span><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div><p><code>sys_read</code>的行为：一旦读到一个<code>LF</code>，就返回到调用者程序，此时他至今为止读到的内容被存放在<code>ECX</code>中保存的地址所指向的内存中。</p>
<p>延伸阅读——<a href="/post/original/cs/io/eof/">EOF，到底怎么回事</a></p>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Hello World Program (Getting input)
</span><span class="c">; Compile with: nasm -f elf helloworld-input.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-input.o -o helloworld-input
</span><span class="c">; Run with: ./helloworld-input
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.data</span>
<span class="nf">msg1</span>        <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Please</span> <span class="no">enter</span> <span class="no">your</span> <span class="no">name</span><span class="p">:</span> <span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">h</span>      <span class="c">; message string asking user for input
</span><span class="c"></span><span class="no">msg2</span>        <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Hello</span><span class="p">,</span> <span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">h</span>                       <span class="c">; message string to use after user has entered their name
</span><span class="c"></span> 
<span class="no">SECTION</span> <span class="no">.bss</span>
<span class="nl">sinput:</span>     <span class="nf">resb</span>    <span class="mi">255</span>                                 <span class="c">; reserve a 255 byte space in memory for the users input string
</span><span class="c"></span> 
<span class="no">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg1</span>
    <span class="nf">call</span>    <span class="no">sprint</span>
 
    <span class="nf">mov</span>     <span class="no">edx</span><span class="p">,</span> <span class="mi">255</span>        <span class="c">; number of bytes to read
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="no">sinput</span>     <span class="c">; reserved space to store our input (known as a buffer)
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c">; read from the STDIN file
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">3</span>          <span class="c">; invoke SYS_READ (kernel opcode 3)
</span><span class="c"></span>    <span class="no">int</span>     <span class="mi">80</span><span class="no">h</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg2</span>
    <span class="nf">call</span>    <span class="no">sprint</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">sinput</span>     <span class="c">; move our buffer into eax (Note: input contains a linefeed)
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprint</span>          <span class="c">; call our print function
</span><span class="c"></span> 
    <span class="no">call</span>    <span class="no">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-input.asm
$ ld -m elf_i386 helloworld-input.o -o helloworld-input
$ ./helloworld-input
Please enter your name: Daniel Givney
Hello, Daniel Givney
</code></pre></div><hr>
<h2 id="lesson-10-数到十">Lesson 10 数到十</h2>
<h3 id="又来了背景知识">又来了，背景知识</h3>
<p>与直觉上相反，在汇编语言中计数并不那么简单直接。首先，我们得传递一个地址给<code>sys_write</code>，不能仅仅将数字加载到寄存器中并调用我们的<code>print</code>函数。其次，数字和字符串在汇编里大不相同。字符串被描述为一系列的 ASCII 值。这里有一个关于 <a href="http://www.asciitable.com/">ASCII</a> 的一个不错的站点(怎么打开净是广告。。。) ，这套编码被用来规范跨计算机的字符串表示的统一标准。</p>
<p>Remember，<code>数</code>是无法打印的——打印出来的都是<code>字符串</code>。为了数到 10，我们需要从标准的整数到对应的 ASCII 字符串的转换。看过 ASCII 码表之后，可以注意到，整数 1 对应的 ASCII 值是 49。实际上，对于 0 到 9 这 10 个整数，加 48 就是其对应的 ASCII 码。</p>
<h3 id="我们的第拾个汇编程序邯郸学步">我们的第拾个汇编程序——邯郸学步</h3>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Hello World Program (Count to 10)
</span><span class="c">; Compile with: nasm -f elf helloworld-10.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-10.o -o helloworld-10
</span><span class="c">; Run with: ./helloworld-10
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c">; ecx is initalised to zero.
</span><span class="c"></span> 
<span class="no">nextNumber</span><span class="p">:</span>
    <span class="nf">inc</span>     <span class="no">ecx</span>             <span class="c">; increment ecx
</span><span class="c"></span> 
    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ecx</span>        <span class="c">; move the address of our integer into eax
</span><span class="c"></span>    <span class="no">add</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">48</span>         <span class="c">; add 48 to our number to convert from integer to ascii for printing
</span><span class="c"></span>    <span class="no">push</span>    <span class="no">eax</span>             <span class="c">; push eax to the stack
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">esp</span>        <span class="c">; get the address of the character on the stack
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprintLF</span>        <span class="c">; call our print function
</span><span class="c"></span> 
    <span class="no">pop</span>     <span class="no">eax</span>             <span class="c">; clean up the stack so we don&#39;t have unneeded bytes taking up space
</span><span class="c"></span>    <span class="no">cmp</span>     <span class="no">ecx</span><span class="p">,</span> <span class="mi">10</span>         <span class="c">; have we reached 10 yet? compare our counter with decimal 10
</span><span class="c"></span>    <span class="no">jne</span>     <span class="no">nextNumber</span>      <span class="c">; jump if not equal and keep counting
</span><span class="c"></span> 
    <span class="no">call</span>    <span class="no">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-10.asm
$ ld -m elf_i386 helloworld-10.o -o helloworld-10
$ ./helloworld-10
<span class="m">1</span>
<span class="m">2</span>
<span class="m">3</span>
<span class="m">4</span>
<span class="m">5</span>
<span class="m">6</span>
<span class="m">7</span>
<span class="m">8</span>
<span class="m">9</span>
:
</code></pre></div><blockquote>
<p>哦噢：我们的数字 10 打印成了冒号(:)，咋了呢？</p>
</blockquote>
<hr>
<h2 id="lesson-11-数到十-itoa">Lesson 11 数到十 (itoa)</h2>
<blockquote>
<p>是 itoa，不是 iota</p>
</blockquote>
<p>为什么 Lesson 10 的程序把 10 打印成了冒号(:)呢。嗯，让我们翻开 ASCII 表，能够看到冒号的 ASCII 值是 58 = 10 + 48，所以按上节的程序写法，就应该输出冒号并没有错。上节所说的 0 到 9 这 10 个整数，我们可以加 48 得到对应的 ASCII 值，然后传给<code>sys_write</code>的输出对应的字符串；但是对于数字 10，他有两位，没有一个单独的 ASCII 来表示 10 的字符串形式。这个两位数需要两个 ASCII，一个表示 1，一个表示 0。因此，传给<code>sys_write</code>一个'4948&rsquo;才是数字 10 的正确字符串形式。10 直接加 48 不行，我们需要把数字的每一位除以 10 后逐个转换</p>
<p>我们引入两个新的子例程，<code>iprint</code>和<code>iprintLF</code>。这些函数用来打印数字的字符串形式，数值本身使用<code>EAX</code>装载，<code>ECX</code>用来计数。然后重复除以 10 的过程，每次把余数加 48，结果值我们<code>PUSH</code>到栈上以备后用。当除以 10 的商(存在<code>EAX</code>里)为 0 时，我们将退出当前循环，进入另一个循环。在该循环里我们通过逐个<code>POP</code>弹栈的方法，打印每一位数字的字符串形式。弹到什么时候为止呢？这正是我们在<code>ECX</code>寄存器里存计数的目的，每弹一个值<code>ECX</code>就减 1，直到减到 0。所有的这些都完成后，程序退出。</p>
<p><strong>除法指令简介</strong></p>
<p><code>DIV</code>和<code>IDIV</code>指令将<code>EAX</code>中的值做为被除数，除以指令的原操作数，商的部分存到<code>EAX</code>(覆盖了原来的被除数)而余数部分存在<code>EDX</code>中。(作者写的挺简单，实现上复杂的多：不同位数的策略；高位存什么、低位存什么；有符号、无符号的区别等等。)</p>
<p>比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">10</span>         <span class="c">; move 10 into eax
</span><span class="c"></span><span class="no">mov</span>     <span class="no">esi</span><span class="p">,</span> <span class="mi">10</span>         <span class="c">; move 10 into esi
</span><span class="c"></span><span class="no">idiv</span>    <span class="no">esi</span>             <span class="c">; divide eax by esi (eax will equal 1 and edx will equal 0)
</span><span class="c"></span><span class="no">idiv</span>    <span class="no">esi</span>             <span class="c">; divide eax by esi again (eax will equal 0 and edx will equal 1)
</span></code></pre></div><p><strong>只存余数，感觉会有问题？</strong></p>
<p>不会，因为这些都是整数。即便除数比被除数大，我们依然能够在余数中找到其原值，这是因为在这种情况下<code>EAX</code>置 0，除法运算运行了 0 次，而被除数的原值作为余数被放到了<code>EDX</code>中。真好~</p>
<h3 id="我们的第拾壹个汇编程序知之非艰">我们的第拾壹个汇编程序——知之非艰</h3>
<blockquote>
<p>注意：仅列出了新函数的注释</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">;------------------------------------------
</span><span class="c">; void iprint(Integer number)
</span><span class="c">; Integer printing function (itoa)
</span><span class="c"></span><span class="nl">iprint:</span>
    <span class="nf">push</span>    <span class="no">eax</span>             <span class="c">; preserve eax on the stack to be restored after function runs
</span><span class="c"></span>    <span class="no">push</span>    <span class="no">ecx</span>             <span class="c">; preserve ecx on the stack to be restored after function runs
</span><span class="c"></span>    <span class="no">push</span>    <span class="no">edx</span>             <span class="c">; preserve edx on the stack to be restored after function runs
</span><span class="c"></span>    <span class="no">push</span>    <span class="no">esi</span>             <span class="c">; preserve esi on the stack to be restored after function runs
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c">; counter of how many bytes we need to print in the end
</span><span class="c"></span> 
<span class="no">divideLoop</span><span class="p">:</span>
    <span class="nf">inc</span>     <span class="no">ecx</span>             <span class="c">; count each byte to print - number of characters
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">edx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c">; empty edx
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">esi</span><span class="p">,</span> <span class="mi">10</span>         <span class="c">; mov 10 into esi
</span><span class="c"></span>    <span class="no">idiv</span>    <span class="no">esi</span>             <span class="c">; divide eax by esi
</span><span class="c"></span>    <span class="no">add</span>     <span class="no">edx</span><span class="p">,</span> <span class="mi">48</span>         <span class="c">; convert edx to it&#39;s ascii representation - edx holds the remainder after a divide instruction
</span><span class="c"></span>    <span class="no">push</span>    <span class="no">edx</span>             <span class="c">; push edx (string representation of an intger) onto the stack
</span><span class="c"></span>    <span class="no">cmp</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">0</span>          <span class="c">; can the integer be divided anymore?
</span><span class="c"></span>    <span class="no">jnz</span>     <span class="no">divideLoop</span>      <span class="c">; jump if not zero to the label divideLoop
</span><span class="c"></span> 
<span class="no">printLoop</span><span class="p">:</span>
    <span class="nf">dec</span>     <span class="no">ecx</span>             <span class="c">; count down each byte that we put on the stack
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">esp</span>        <span class="c">; mov the stack pointer into eax for printing
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprint</span>          <span class="c">; call our string print function
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">eax</span>             <span class="c">; remove last character from the stack to move esp forward
</span><span class="c"></span>    <span class="no">cmp</span>     <span class="no">ecx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c">; have we printed all bytes we pushed onto the stack?
</span><span class="c"></span>    <span class="no">jnz</span>     <span class="no">printLoop</span>       <span class="c">; jump is not zero to the label printLoop
</span><span class="c"></span> 
    <span class="no">pop</span>     <span class="no">esi</span>             <span class="c">; restore esi from the value we pushed onto the stack at the start
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">edx</span>             <span class="c">; restore edx from the value we pushed onto the stack at the start
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">ecx</span>             <span class="c">; restore ecx from the value we pushed onto the stack at the start
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">eax</span>             <span class="c">; restore eax from the value we pushed onto the stack at the start
</span><span class="c"></span>    <span class="no">ret</span>
 
 
<span class="c">;------------------------------------------
</span><span class="c">; void iprintLF(Integer number)
</span><span class="c">; Integer printing function with linefeed (itoa)
</span><span class="c"></span><span class="nl">iprintLF:</span>
    <span class="nf">call</span>    <span class="no">iprint</span>          <span class="c">; call our integer printing function
</span><span class="c"></span> 
    <span class="no">push</span>    <span class="no">eax</span>             <span class="c">; push eax onto the stack to preserve it while we use the eax register in this function
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">0</span><span class="no">Ah</span>        <span class="c">; move 0Ah into eax - 0Ah is the ascii character for a linefeed
</span><span class="c"></span>    <span class="no">push</span>    <span class="no">eax</span>             <span class="c">; push the linefeed onto the stack so we can get the address
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">esp</span>        <span class="c">; move the address of the current stack pointer into eax for sprint
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprint</span>          <span class="c">; call our sprint function
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">eax</span>             <span class="c">; remove our linefeed character from the stack
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">eax</span>             <span class="c">; restore the original value of eax before our function was called
</span><span class="c"></span>    <span class="no">ret</span>
 
 
<span class="c">;------------------------------------------
</span><span class="c">; int slen(String message)
</span><span class="c">; String length calculation function
</span><span class="c"></span><span class="nl">slen:</span>
    <span class="nf">push</span>    <span class="no">ebx</span>
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="no">eax</span>
 
<span class="nl">nextchar:</span>
    <span class="nf">cmp</span>     <span class="no">byte</span> <span class="p">[</span><span class="no">eax</span><span class="p">],</span> <span class="mi">0</span>
    <span class="nf">jz</span>      <span class="no">finished</span>
    <span class="nf">inc</span>     <span class="no">eax</span>
    <span class="nf">jmp</span>     <span class="no">nextchar</span>
 
<span class="nl">finished:</span>
    <span class="nf">sub</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ebx</span>
    <span class="nf">pop</span>     <span class="no">ebx</span>
    <span class="nf">ret</span>
 
 
<span class="c">;------------------------------------------
</span><span class="c">; void sprint(String message)
</span><span class="c">; String printing function
</span><span class="c"></span><span class="nl">sprint:</span>
    <span class="nf">push</span>    <span class="no">edx</span>
    <span class="nf">push</span>    <span class="no">ecx</span>
    <span class="nf">push</span>    <span class="no">ebx</span>
    <span class="nf">push</span>    <span class="no">eax</span>
    <span class="nf">call</span>    <span class="no">slen</span>
 
    <span class="nf">mov</span>     <span class="no">edx</span><span class="p">,</span> <span class="no">eax</span>
    <span class="nf">pop</span>     <span class="no">eax</span>
 
    <span class="nf">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="no">eax</span>
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">int</span>     <span class="mi">80</span><span class="no">h</span>
 
    <span class="nf">pop</span>     <span class="no">ebx</span>
    <span class="nf">pop</span>     <span class="no">ecx</span>
    <span class="nf">pop</span>     <span class="no">edx</span>
    <span class="nf">ret</span>
 
 
<span class="c">;------------------------------------------
</span><span class="c">; void sprintLF(String message)
</span><span class="c">; String printing with line feed function
</span><span class="c"></span><span class="nl">sprintLF:</span>
    <span class="nf">call</span>    <span class="no">sprint</span>
 
    <span class="nf">push</span>    <span class="no">eax</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">0</span><span class="no">AH</span>
    <span class="nf">push</span>    <span class="no">eax</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">esp</span>
    <span class="nf">call</span>    <span class="no">sprint</span>
    <span class="nf">pop</span>     <span class="no">eax</span>
    <span class="nf">pop</span>     <span class="no">eax</span>
    <span class="nf">ret</span>
 
 
<span class="c">;------------------------------------------
</span><span class="c">; void exit()
</span><span class="c">; Exit program and restore resources
</span><span class="c"></span><span class="nl">quit:</span>
    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">int</span>     <span class="mi">80</span><span class="no">h</span>
    <span class="nf">ret</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Hello World Program (Count to 10 itoa)
</span><span class="c">; Compile with: nasm -f elf helloworld-itoa.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-itoa.o -o helloworld-itoa
</span><span class="c">; Run with: ./helloworld-itoa
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="mi">0</span>
 
<span class="nl">nextNumber:</span>
    <span class="nf">inc</span>     <span class="no">ecx</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ecx</span>
    <span class="nf">call</span>    <span class="no">iprintLF</span>        <span class="c">; NOTE call our new integer printing function (itoa)
</span><span class="c"></span>    <span class="no">cmp</span>     <span class="no">ecx</span><span class="p">,</span> <span class="mi">10</span>
    <span class="nf">jne</span>     <span class="no">nextNumber</span>
 
    <span class="nf">call</span>    <span class="no">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf helloworld-itoa.asm
$ ld -m elf_i386 helloworld-itoa.o -o helloworld-itoa
$ ./helloworld-itoa
<span class="m">1</span>
<span class="m">2</span>
<span class="m">3</span>
<span class="m">4</span>
<span class="m">5</span>
<span class="m">6</span>
<span class="m">7</span>
<span class="m">8</span>
<span class="m">9</span>
<span class="m">10</span>
</code></pre></div><hr>
<h2 id="lesson-12-计算加法">Lesson 12 计算——加法</h2>
<p>这个程序，将寄存器<code>EAX</code>和<code>EBX</code>中的值相加，和保存在<code>EAX</code>中。首先<code>MOV</code>其中一个加数到<code>EAX</code>(本例中为 90)，然后<code>MOV</code>另一个加数到<code>EBX</code>(本例中为9)。我们需要调用<code>ADD</code>指令来实现加法运算。<code>EBX</code>和<code>EAX</code>中的值将被加到一起，而结果和将被存回指令最左边的寄存器中(也就是本例的<code>EAX</code>)。最后调用我们引以为傲的<code>数值-&gt;字符串</code>打印函数来完成我们的程序。</p>
<h3 id="我们的第拾贰个汇编程序聚沙成塔">我们的第拾贰个汇编程序——聚沙成塔</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Calculator (Addition)
</span><span class="c">; Compile with: nasm -f elf calculator-addition.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-addition.o -o calculator-addition
</span><span class="c">; Run with: ./calculator-addition
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">90</span>     <span class="c">; move our first number into eax
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">9</span>      <span class="c">; move our second number into ebx
</span><span class="c"></span>    <span class="no">add</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ebx</span>    <span class="c">; add ebx to eax
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">iprintLF</span>    <span class="c">; call our integer print with linefeed function
</span><span class="c"></span> 
    <span class="no">call</span>    <span class="no">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf calculator-addition.asm
$ ld -m elf_i386 calculator-addition.o -o calculator-addition
$ ./calculator-addition
<span class="m">99</span>
</code></pre></div><hr>
<h2 id="lesson-13-计算减法">Lesson 13 计算——减法</h2>
<p>这个程序与 Lesson 12 的唯一区别就是加法指令<code>ADD</code>，换成了减法指令<code>SUB</code></p>
<h3 id="我们的第拾叁个汇编程序红衰翠减">我们的第拾叁个汇编程序——红衰翠减</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Calculator (Subtraction)
</span><span class="c">; Compile with: nasm -f elf calculator-subtraction.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-subtraction.o -o calculator-subtraction
</span><span class="c">; Run with: ./calculator-subtraction
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">90</span>     <span class="c">; move our first number into eax
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">9</span>      <span class="c">; move our second number into ebx
</span><span class="c"></span>    <span class="no">sub</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ebx</span>    <span class="c">; subtract ebx from eax
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">iprintLF</span>    <span class="c">; call our integer print with linefeed function
</span><span class="c"></span> 
    <span class="no">call</span>    <span class="no">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf calculator-subtraction.asm
$ ld -m elf_i386 calculator-subtraction.o -o calculator-subtraction
$ ./calculator-subtraction
<span class="m">81</span>
</code></pre></div><hr>
<h2 id="lesson-14-计算乘法">Lesson 14 计算——乘法</h2>
<p>在本程序中，我们将用<code>EBX</code>中的值与<code>EAX</code>中的值相乘。两个整数按照和 Lesson 12 一样的方式分别存入两个寄存器。这次的指令主角是<code>MUL</code>，他是 NASM 中为数不多的几个单操作数指令之一。<code>MUL</code>指令总是将其操作数与EAX中的值相乘，并将积存回<code>EAX</code></p>
<h3 id="我们的第拾肆个汇编程序一登龙门">我们的第拾肆个汇编程序——一登龙门</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Calculator (Multiplication)
</span><span class="c">; Compile with: nasm -f elf calculator-multiplication.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-multiplication.o -o calculator-multiplication
</span><span class="c">; Run with: ./calculator-multiplication
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">90</span>     <span class="c">; move our first number into eax
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">9</span>      <span class="c">; move our second number into ebx
</span><span class="c"></span>    <span class="no">mul</span>     <span class="no">ebx</span>         <span class="c">; multiply eax by ebx
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">iprintLF</span>    <span class="c">; call our integer print with linefeed function
</span><span class="c"></span> 
    <span class="no">call</span>    <span class="no">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf calculator-multiplication.asm
$ ld -m elf_i386 calculator-multiplication.o -o calculator-multiplication
$ ./calculator-multiplication
<span class="m">810</span>
</code></pre></div><hr>
<h2 id="lesson-15-计算除法">Lesson 15 计算——除法</h2>
<p>除法指令我们已经见识过了，我们曾用他来实现数字值到 ASCII 码的转换。本例中，依然使用<code>EAX</code>和<code>EBX</code>。他们分别保存被除数和除数。如前所述，<code>DIV</code>指令的行为如下：用其操作数去除<code>EAX</code>中的值，商保存到<code>EAX</code>，而余数保存到<code>EDX</code>。我们将商和余数都打印出来</p>
<h3 id="又见除法的第拾伍个汇编程序经分之术">又见除法的第拾伍个汇编程序——经分之术</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Calculator (Division)
</span><span class="c">; Compile with: nasm -f elf calculator-division.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-division.o -o calculator-division
</span><span class="c">; Run with: ./calculator-division
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.data</span>
<span class="nf">msg1</span>        <span class="no">db</span>      <span class="err">&#39;</span> <span class="no">remainder</span> <span class="err">&#39;</span>      <span class="c">; a message string to correctly output result
</span><span class="c"></span> 
<span class="no">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">90</span>     <span class="c">; move our first number into eax
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">9</span>      <span class="c">; move our second number into ebx
</span><span class="c"></span>    <span class="no">div</span>     <span class="no">ebx</span>         <span class="c">; divide eax by ebx
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">iprint</span>      <span class="c">; call our integer print function on the quotient
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg1</span>   <span class="c">; move our message string into eax
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprint</span>      <span class="c">; call our string print function
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">edx</span>    <span class="c">; move our remainder into eax
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">iprintLF</span>    <span class="c">; call our integer printing with linefeed function
</span><span class="c"></span> 
    <span class="no">call</span>    <span class="no">quit</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf calculator-division.asm
$ ld -m elf_i386 calculator-division.o -o calculator-division
$ ./calculator-division
<span class="m">10</span> remainder <span class="m">0</span>
</code></pre></div><hr>
<h2 id="lesson-16-计算atoi">Lesson 16 计算——atoi</h2>
<p>将算数运算中的数值写死在代码里并不激动人心，这次我们要从命令行参数中动态获取变化的数值！</p>
<p><strong>程序步骤</strong></p>
<ul>
<li>我们先用<code>POP</code>从栈上获得命令行参数的个数，并保存在<code>ECX</code>寄存器；然后继续<code>POP</code>出命令的名称，从<code>ECX</code>中去掉他的计数；随后循环的弹出每个参数并执行我们的加法逻辑。</li>
<li>和输出一样，输入给我们的也都是字符串。在进行加法运算前，我们需要一个和输出时相反的转换操作：ASCII 码-&gt;数字值，没有这个步骤加法的结果将不正确。</li>
<li>这个转换操作由我们新引入的子例程 Ascii to Integer(atoi) 来完成。这个函数将 ASCII 码值对应的数字保存在<code>EAX</code>寄存器。每次我们都把<code>EAX</code>的值加到<code>EDX</code>里去。如果传递给我们的 ASCII 码不是表示 0-9 那是个数字的，就用 0 替代他。</li>
<li>所有参数都经过转换并加到一起后，打印和并退出</li>
</ul>
<p><strong>atoi 原理</strong></p>
<p>将 ASCII 码转为整数并非易事。还记得我们之前是怎么把整数转成 ASCII 码的？现在我们显然要进行其逆运算。</p>
<p>首先，将字符串的地址移入<code>ESI</code>(著名的源址寄存器)；然后，我们逐字节的遍历字符串(试着将每个字节看做是一个数字或十进制位)。对于每个数字，我们检测其值是否介于 48 到 57 之间( 0-9 的 ASCII 码)，如果满足条件，就执行以下逻辑：</p>
<p>码值减去 48——得到该码值所表示的数字的十进制整数值，这个值存入<code>EAX</code>，然后<code>EAX</code>乘以 10，随着循环的进行，每一位的维权都在随着乘以 10 而提升，从而归到其所占的位上。</p>
<p>当所有的字节都按照上面的逻辑处理完成，返回结果值之前，我们还要进入最后的一步：由于最后一位数字是个位数，他不应该乘以 10，但我们上面的逻辑却这样做了。我们需要简单的除以一次 10 来纠正这个错误。当然，如果传递给我们程序的参数不是整数，这个除法操作就省略掉。</p>
<p><strong>接下来的程序中使用了 BL 寄存器，这里简单说下</strong></p>
<p>通用寄存器的个数就没怎么变过，但是其位数却在一扩再扩以提高CPU的计算能力。汇编指令中写<code>BL</code>的意思是，使用32位<code>EBX</code>寄存器的<code>低8位</code>，因为单个 ASCII 码值只需要一个字节就可以放下。如果我们使用整个32位寄存器来存储这一个字节的数据，那么其中的24位都对我们毫无意义。</p>
<p>对于<code>EBX</code>，其<code>0-16bits</code>段称为<code>BX</code>，而<code>BX</code>则包含<code>BL</code>和<code>BH</code>(低8位，高8位)，显然我们只需要<code>BL</code>。</p>
<p>正向的学习汇编，往往从头开始捣寄存器的历史，名称的含义和位的大小等等。本教程是反向的，通过程序中用到的必要元素来追溯关键的概念和原理。完整的寄存器知识超出了本教程的范围，但之后的篇章将继续讨论，毕竟写汇编嘛，我们绕不过寄存器去 :-)</p>
<h3 id="欢迎我们的第拾陆个汇编程序反朴归真">欢迎我们的第拾陆个汇编程序——反朴归真</h3>
<blockquote>
<p>注意：funcitons.asm 只列出了新引入的 atoi 子例程的代码</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">;------------------------------------------
</span><span class="c">; int atoi(Integer number)
</span><span class="c">; Ascii to integer function (atoi)
</span><span class="c"></span><span class="nl">atoi:</span>
    <span class="nf">push</span>    <span class="no">ebx</span>             <span class="c">; preserve ebx on the stack to be restored after function runs
</span><span class="c"></span>    <span class="no">push</span>    <span class="no">ecx</span>             <span class="c">; preserve ecx on the stack to be restored after function runs
</span><span class="c"></span>    <span class="no">push</span>    <span class="no">edx</span>             <span class="c">; preserve edx on the stack to be restored after function runs
</span><span class="c"></span>    <span class="no">push</span>    <span class="no">esi</span>             <span class="c">; preserve esi on the stack to be restored after function runs
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">esi</span><span class="p">,</span> <span class="no">eax</span>        <span class="c">; move pointer in eax into esi (our number to convert)
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">0</span>          <span class="c">; initialise eax with decimal value 0
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ecx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c">; initialise ecx with decimal value 0
</span><span class="c"></span> 
<span class="no">.multiplyLoop</span><span class="p">:</span>
    <span class="nf">xor</span>     <span class="no">ebx</span><span class="p">,</span> <span class="no">ebx</span>        <span class="c">; resets both lower and uppper bytes of ebx to be 0
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">bl</span><span class="p">,</span> <span class="p">[</span><span class="no">esi</span><span class="err">+</span><span class="no">ecx</span><span class="p">]</span>   <span class="c">; move a single byte into ebx register&#39;s lower half
</span><span class="c"></span>    <span class="no">cmp</span>     <span class="no">bl</span><span class="p">,</span> <span class="mi">48</span>          <span class="c">; compare ebx register&#39;s lower half value against ascii value 48 (char value 0)
</span><span class="c"></span>    <span class="no">jl</span>      <span class="no">.finished</span>       <span class="c">; jump if less than to label finished
</span><span class="c"></span>    <span class="no">cmp</span>     <span class="no">bl</span><span class="p">,</span> <span class="mi">57</span>          <span class="c">; compare ebx register&#39;s lower half value against ascii value 57 (char value 9)
</span><span class="c"></span>    <span class="no">jg</span>      <span class="no">.finished</span>       <span class="c">; jump if greater than to label finished
</span><span class="c"></span> 
    <span class="no">sub</span>     <span class="no">bl</span><span class="p">,</span> <span class="mi">48</span>          <span class="c">; convert ebx register&#39;s lower half to decimal representation of ascii value
</span><span class="c"></span>    <span class="no">add</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ebx</span>        <span class="c">; add ebx to our interger value in eax
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">10</span>         <span class="c">; move decimal value 10 into ebx
</span><span class="c"></span>    <span class="no">mul</span>     <span class="no">ebx</span>             <span class="c">; multiply eax by ebx to get place value
</span><span class="c"></span>    <span class="no">inc</span>     <span class="no">ecx</span>             <span class="c">; increment ecx (our counter register)
</span><span class="c"></span>    <span class="no">jmp</span>     <span class="no">.multiplyLoop</span>   <span class="c">; continue multiply loop
</span><span class="c"></span> 
<span class="no">.finished</span><span class="p">:</span>
    <span class="nf">cmp</span>     <span class="no">ecx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c">; compare ecx register&#39;s value against decimal 0 (our counter register)
</span><span class="c"></span>    <span class="no">je</span>      <span class="no">.restore</span>        <span class="c">; jump if equal to 0 (no integer arguments were passed to atoi)
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">10</span>         <span class="c">; move decimal value 10 into ebx
</span><span class="c"></span>    <span class="no">div</span>     <span class="no">ebx</span>             <span class="c">; divide eax by value in ebx (in this case 10)
</span><span class="c"></span> 
<span class="no">.restore</span><span class="p">:</span>
    <span class="nf">pop</span>     <span class="no">esi</span>             <span class="c">; restore esi from the value we pushed onto the stack at the start
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">edx</span>             <span class="c">; restore edx from the value we pushed onto the stack at the start
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">ecx</span>             <span class="c">; restore ecx from the value we pushed onto the stack at the start
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">ebx</span>             <span class="c">; restore ebx from the value we pushed onto the stack at the start
</span><span class="c"></span>    <span class="no">ret</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Calculator (ATOI)
</span><span class="c">; Compile with: nasm -f elf calculator-atoi.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-atoi.o -o calculator-atoi
</span><span class="c">; Run with: ./calculator-atoi 20 1000 317
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
    <span class="nf">pop</span>     <span class="no">ecx</span>             <span class="c">; first value on the stack is the number of arguments
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">edx</span>             <span class="c">; second value on the stack is the program name (discarded when we initialise edx)
</span><span class="c"></span>    <span class="no">sub</span>     <span class="no">ecx</span><span class="p">,</span> <span class="mi">1</span>          <span class="c">; decrease ecx by 1 (number of arguments without program name)
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">edx</span><span class="p">,</span> <span class="mi">0</span>          <span class="c">; initialise our data register to store additions
</span><span class="c"></span> 
<span class="no">nextArg</span><span class="p">:</span>
    <span class="nf">cmp</span>     <span class="no">ecx</span><span class="p">,</span> <span class="mi">0</span><span class="no">h</span>         <span class="c">; check to see if we have any arguments left
</span><span class="c"></span>    <span class="no">jz</span>      <span class="no">noMoreArgs</span>      <span class="c">; if zero flag is set jump to noMoreArgs label (jumping over the end of the loop)
</span><span class="c"></span>    <span class="no">pop</span>     <span class="no">eax</span>             <span class="c">; pop the next argument off the stack
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">atoi</span>            <span class="c">; convert our ascii string to decimal integer
</span><span class="c"></span>    <span class="no">add</span>     <span class="no">edx</span><span class="p">,</span> <span class="no">eax</span>        <span class="c">; perform our addition logic
</span><span class="c"></span>    <span class="no">dec</span>     <span class="no">ecx</span>             <span class="c">; decrease ecx (number of arguments left) by 1
</span><span class="c"></span>    <span class="no">jmp</span>     <span class="no">nextArg</span>         <span class="c">; jump to nextArg label
</span><span class="c"></span> 
<span class="no">noMoreArgs</span><span class="p">:</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">edx</span>        <span class="c">; move our data result into eax for printing
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">iprintLF</span>        <span class="c">; call our integer printing with linefeed function
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">quit</span>            <span class="c">; call our q
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf calculator-atoi.asm
$ ld -m elf_i386 calculator-atoi.o -o calculator-atoi
$ ./calculator-atoi <span class="m">20</span> <span class="m">1000</span> <span class="m">317</span>
<span class="m">1337</span>
</code></pre></div><hr>
<h2 id="lesson-17-命名空间">Lesson 17 命名空间</h2>
<p>对于任何包含大量代码库的软件项目，命名空间都是不可或缺的构造。命名空间为标识符引入作用域的概念，使得重用命名约定成为可能，同时增强了代码的可读性和可维护性。在汇编语言中，全局标签标识子例程，而局部标签用来实现命名空间。</p>
<p>之前的教程中，我们都只使用了全局标签。这意味着即便是实现相同逻辑的代码块，也必须有全局唯一的标签名，前面的<code>finished</code>标签就是一例。同属一个全局作用域，意味着当在一个函数中需要跳出循环时，直接<code>JMP</code>到该函数中的<code>finished</code>标签就行。然而，如果我们需要从另一个函数中跳出循环，和<code>finished</code>代码块功能相同的代码我们得改名。我们希望能重用<code>finished</code>这个名字，因为他能向代码的阅读者暗示出某种已知的逻辑。</p>
<p>局部标签以<code>.</code>开头，比如：<code>.finished</code>。随着我们的 functions.asm 不断扩展，你可能已经注意到他的出现了。一个局部标签的命名空间，由离他最近的前面的一个全局标签限定。你可以使用<code>JMP</code>跳转到局部标签，编译器将通过当前调用的作用域(基于其之上的全局标签)计算出应该引用哪一个局部标签。</p>
<h3 id="第拾柒个汇编程序各安生业">第拾柒个汇编程序——各安生业</h3>
<p>functions.asm 略</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c">; Namespace
</span><span class="c">; Compile with: nasm -f elf namespace.asm
</span><span class="c">; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 namespace.o -o namespace
</span><span class="c">; Run with: ./namespace
</span><span class="c"></span> 
<span class="err">%</span><span class="nf">include</span>        <span class="err">&#39;</span><span class="no">functions.asm</span><span class="err">&#39;</span>
 
<span class="nf">SECTION</span> <span class="no">.data</span>
<span class="nf">msg1</span>        <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Jumping</span> <span class="no">to</span> <span class="no">finished</span> <span class="no">label.</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">h</span>        <span class="c">; a message string
</span><span class="c"></span><span class="no">msg2</span>        <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Inside</span> <span class="no">subroutine</span> <span class="no">number</span><span class="p">:</span> <span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">h</span>        <span class="c">; a message string
</span><span class="c"></span><span class="no">msg3</span>        <span class="no">db</span>      <span class="err">&#39;</span><span class="no">Inside</span> <span class="no">subroutine</span> <span class="err">&#34;</span><span class="no">finished</span><span class="err">&#34;</span><span class="p">.</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="no">h</span>     <span class="c">; a message string
</span><span class="c"></span> 
<span class="no">SECTION</span> <span class="no">.text</span>
<span class="nf">global</span>  <span class="no">_start</span>
 
<span class="nl">_start:</span>
 
<span class="nl">subrountineOne:</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg1</span>       <span class="c">; move the address of msg1 into eax
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprintLF</span>        <span class="c">; call our string printing with linefeed function
</span><span class="c"></span>    <span class="no">jmp</span>     <span class="no">.finished</span>       <span class="c">; jump to the local label under the subrountineOne scope
</span><span class="c"></span> 
<span class="no">.finished</span><span class="p">:</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg2</span>       <span class="c">; move the address of msg2 into eax
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprint</span>          <span class="c">; call our string printing function
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>          <span class="c">; move the value one into eax (for subroutine number one)
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">iprintLF</span>        <span class="c">; call our integer printing function with linefeed function
</span><span class="c"></span> 
<span class="no">subrountineTwo</span><span class="p">:</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg1</span>       <span class="c">; move the address of msg1 into eax
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprintLF</span>        <span class="c">; call our string print with linefeed function
</span><span class="c"></span>    <span class="no">jmp</span>     <span class="no">.finished</span>       <span class="c">; jump to the local label under the subrountineTwo scope
</span><span class="c"></span> 
<span class="no">.finished</span><span class="p">:</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg2</span>       <span class="c">; move the address of msg2 into eax
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprint</span>          <span class="c">; call our string printing function
</span><span class="c"></span>    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">2</span>          <span class="c">; move the value two into eax (for subroutine number two)
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">iprintLF</span>        <span class="c">; call our integer printing function with linefeed function
</span><span class="c"></span> 
    <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg1</span>       <span class="c">; move the address of msg1 into eax
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprintLF</span>        <span class="c">; call our string printing with linefeed function
</span><span class="c"></span>    <span class="no">jmp</span>     <span class="no">finished</span>        <span class="c">; jump to the global label finished
</span><span class="c"></span> 
<span class="no">finished</span><span class="p">:</span>
    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">msg3</span>       <span class="c">; move the address of msg3 into eax
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">sprintLF</span>        <span class="c">; call our string printing with linefeed function
</span><span class="c"></span>    <span class="no">call</span>    <span class="no">quit</span>            <span class="c">; call our quit function
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ nasm -f elf namespace.asm
$ ld -m elf_i386 namespace.o -o namespace
$ ./namespace
Jumping to finished label.
Inside subroutine number: <span class="m">1</span>
Jumping to finished label.
Inside subroutine number: <span class="m">2</span>
Jumping to finished label.
Inside subroutine <span class="s2">&#34;finished&#34;</span>.
</code></pre></div><hr>
<h2 id="lesson-18-fizzbuzz-游戏">Lesson 18 FizzBuzz 游戏</h2>
<hr>
<h2 id="lesson-19-执行命令">Lesson 19 执行命令</h2>
<hr>
<h2 id="lesson-20-process-forking">Lesson 20 Process Forking</h2>
<hr>
<h2 id="lesson-21-输出时间">Lesson 21 输出时间</h2>
<hr>
<h2 id="lesson-22-文件操作create">Lesson 22 文件操作——Create</h2>
<hr>
<h2 id="lesson-23-文件操作write">Lesson 23 文件操作——Write</h2>
<hr>
<h2 id="lesson-24-文件操作open">Lesson 24 文件操作——Open</h2>
<hr>
<h2 id="lesson-25-文件操作read">Lesson 25 文件操作——Read</h2>
<hr>
<h2 id="lesson-26-文件操作close">Lesson 26 文件操作——Close</h2>
<hr>
<h2 id="lesson-27-文件操作seek">Lesson 27 文件操作——Seek</h2>
<hr>
<h2 id="lesson-28-文件操作delete">Lesson 28 文件操作——Delete</h2>
<hr>
<h2 id="lesson-29-套接字create">Lesson 29 套接字——Create</h2>
<hr>
<h2 id="lesson-30-套接字bind">Lesson 30 套接字——Bind</h2>
<hr>
<h2 id="lesson-31-套接字listen">Lesson 31 套接字——Listen</h2>
<hr>
<h2 id="lesson-32-套接字accept">Lesson 32 套接字——Accept</h2>
<hr>
<h2 id="lesson-33-套接字read">Lesson 33 套接字——Read</h2>
<hr>
<h2 id="lesson-34-套接字write">Lesson 34 套接字——Write</h2>
<hr>
<h2 id="lesson-35-套接字close">Lesson 35 套接字——Close</h2>
<hr>
<h2 id="lesson-36-套接字下载网页">Lesson 36 套接字——下载网页</h2>


        

        

        
          

          
        
      </article>

      
        <ul class="pager blog-pager">
          
          
            <li class="next">
              <a href="https://newlooper.github.io/post/original/cs/io/eof/" data-toggle="tooltip" data-placement="top" title="EOF，到底怎么回事">后一篇 &rarr;</a>
            </li>
          
        </ul>
      


      
        
          
          <div class="disqus-comments">                  
            <button id="show-comments" class="btn btn-default" type="button">显示 <span class="disqus-comment-count" data-disqus-url="https://newlooper.github.io/post/trans/learn-assembly-language">则评论</span></button>
            <div id="disqus_thread"></div>

            <script type="text/javascript">
              var disqus_config = function () {
              this.page.url = 'https:\/\/newlooper.github.io\/post\/trans\/learn-assembly-language';
            };

          </script>
          </div>
          
        
        
      

    </div>
  </div>
</div>

      
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="https://github.com/newlooper" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://newlooper.github.io">Dylan Cheng</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2020
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://newlooper.github.io/">Looper 的博客</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          由 <a href="https://gohugo.io">Hugo v0.74.3</a> 强力驱动 &nbsp;&bull;&nbsp; 主题 <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> 移植自 <a href="https://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://newlooper.github.io/js/main.js"></script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://newlooper.github.io/js/load-photoswipe.js"></script>








<script type="text/javascript">
$(function(){
  $('#show-comments').on('click', function(){
    var disqus_shortname = 'newlooper';
      
    (function() {
      var disqus = document.createElement('script'); 
      disqus.type = 'text/javascript'; 
      disqus.async = true;
      disqus.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(disqus);
    })();
      
    $(this).hide(); 
    });
  });
      
</script>
<script id="dsq-count-scr" src="//newlooper.disqus.com/count.js" async></script>




    
  </body>
</html>

