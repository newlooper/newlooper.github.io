<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Looper 的博客</title>
    <link>https://newlooper.github.io/post/</link>
    <description>Recent content in Posts on Looper 的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 03 Aug 2020 15:52:41 +0800</lastBuildDate>
    
	<atom:link href="https://newlooper.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>EOF，到底怎么回事</title>
      <link>https://newlooper.github.io/post/original/cs/io/eof/</link>
      <pubDate>Mon, 03 Aug 2020 15:52:41 +0800</pubDate>
      
      <guid>https://newlooper.github.io/post/original/cs/io/eof/</guid>
      <description>TL;DR 首先，确未想到，为说清楚这个玩意儿，居然要用不少的篇幅；其次，当涉及对一些概念、原理的追溯时，递归到多深的地步，也不容易拿捏；好在，写这些文字主要是为了将来碰到某些反直觉的情况时可以有个快捷解答；最后若能得到碰巧逛到这里的同仁指点迷津，纠正错误，互通有无，就算赚到了 :-）
希望读完此文，能够消除一些关于 EOF 的疑惑，再碰到关于她的一些争论时，大家能够相视一笑。
愿此文，能解释
 什么是 EOF？ 为什么需要 EOF？ 文件里包不包含 EOF？ 终端输入时的 EOF 的表示方式和处理行为是怎么样的? 不同计算机语言的 EOF 如何定义的？ …… may your blade never dull   section-0 概念澄清  In computing, end-of-file (commonly abbreviated EOF) is a condition in a computer operating system where no more data can be read from a data source. The data source is usually called a file or stream.
——Wikipedia
 难为下定义的人们，描述既不能太复杂，又要尽可能的说清一个事物的本质。
好，从上面的叙述中，我们萃取出关于 EOF：</description>
    </item>
    
    <item>
      <title>Learn Assembly Language 汇编语言学习(拙译)</title>
      <link>https://newlooper.github.io/post/trans/learn-assembly-language/</link>
      <pubDate>Sat, 01 Aug 2020 16:29:01 +0800</pubDate>
      
      <guid>https://newlooper.github.io/post/trans/learn-assembly-language/</guid>
      <description>Index-0 原址：https://asmtutor.com/
环境：nasm on x64 linux
TL;DR   动机：程序员——多掌握几门计算机语言，还是有好处的
  主题：汇编语言——有其不可替代的作用
  呈示：天下语言逾千——汇编笑看沉舟侧畔
  展开：欲知程序真相——反编译难，反汇编易
  再现：大道器也不器——初见时如茶味甘苦，洞悉后若灌顶醍醐；原以为听多说多皆已昨，忽回首似曾相识又如陌；罢，风流不在谈峰健，相对无言味更长……
    文章作者自己说 This project was put together to teach myself NASM assembly language on linux.
欸~，原来是很窄众的哦。呵呵。
写的虽然通俗，但依然能感到其面向的并不是毫无编程基础的人群，所谓“某子不能隐真恶”，无论怎样努力的将大量概念、原理、知识安排到看似聊天般的文字中，这里都要提醒读者注意，提防因为好奇心而陷入递归学习的泥潭……
  Lesson 1 Hello, world! 背景知识 汇编语言是一种低级语言，汇编程序员与底层硬件之间唯一的接口只有内核本身。用汇编语言编程，涉及到 Linux 内核提供的系统调用机制。这些系统调用是操作系统内置的库函数，提供诸如读取键盘输入以及将输出显示到屏幕之类的功能。
当用户程序发起系统调用时，内核将立即挂起该程序，进而通过驱动程序让相关硬件完成用户程序所发起的任务请求，最后，将控制权交还给用户程序。
 注意：驱动程序的驱动二字，形象的描述了内核对硬件的控制
 在汇编语言中发起系统调用，需要向EAX寄存器写入相应调用的函数编号(也即：操作码OPCODE)，同时设置其他几个寄存器的值作为实际参数，一切准备停当后，指令INT发送一个软中断，内核收到中断请求后接受参数并执行相应的库函数。简单直接。
来写我们的第壹个汇编程序吧——美玉有瑕 还是从著名的例子——$$Hello, world! $$ 开始，我们的汇编程序将把这个让无数程序员产生我已经学会这种语言了的错觉的字符串打印到标准输出上。
首先，在数据段定义一个msg变量，并赋给其一个字符串类型的值作为我们程序的输出。而在代码段中，通过编写全局标签_start:，告诉内核我们(写的诗)程序开始的地方(没有远方)
实际参数通过以下寄存器传给内核：
 EDX存储字符串的长度(字节数) ECX存储字符串的首地址(定义在数据段中的msg变量加载到内存后所在的位置) EBX存储字符串写操作的目标文件——本例中是STDOUT  数据类型和实际参数的含义可以在函数定义中查到。</description>
    </item>
    
  </channel>
</rss>